<!doctype html>
<html>
<section class="devlog-box" style="margin-top:24px; max-width:820px;">
  <div class="devlog-header" style="background:linear-gradient(90deg,#233045,#2563eb);color:#fff;font-weight:700;font-size:15px;padding:10px 12px 8px 12px;border-radius:8px 8px 0 0;">
    Devlog
  </div>
  <div class="devlog-body" style="background:linear-gradient(180deg,#1e293b,#071421 60%);color:#cfe8ff;font-size:14px;padding:16px 14px 20px 14px;border-radius:0 0 8px 8px;border:1px solid #233045;">
    <strong>2024-06-15</strong> – I give up.  
    <ul>
      <li>I'm just gonna be straight-forward, this whole site was literally built by nothing but AI and constant testing to make sure everything works out, the only thing I can't get right however is the algorithm, some find it to be working, some don't. So please, I beg of users who truly appreciate the time I wasted to make this site out of pure spite and frustration towards CR:TOA's current state, to use this more of a template or a testing ground rather than a perfect tool that you can do however you want with it and expect perfect results. If you want any small additional QoL changes made to the site (do not come complaining to me about the algorithm), ping or DM me anytime. - LazyGuardian</li>
      <li>If you want higher chances of getting a satisfactory solution, I'd recommend not selecting too many shapes, just enough.</li>
    </ul>
    <!--
      To update the Devlog: Only change this HTML! Add new sections, write markdown-style lists, etc.
    -->
  </div>
</section>
<head>
<meta charset="utf-8"/>
<title>CR:TOA Rift Resistance Optimizer</title>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<style>
  :root{
    --bg:#0f1724;
    --muted:#9fb6d4;
    --accent:#cfe8ff;
    --card:#0b1220;
    --card-border: rgba(255,255,255,0.04);
    --rare:#2679F8;
    --epic:#D85FFF;
    --super:#F84747;
    --unique:#FF9C00;
    --highlight: rgba(255,193,7,0.85);
  }
  html,body{height:100%;width:100%;margin:0;padding:10px;background:var(--bg);color:var(--accent);font-family:system-ui, -apple-system, "Segoe UI", Roboto, Arial;box-sizing:border-box;}
  *{box-sizing:inherit}
  h1{margin:0 0 10px 0;font-size:16px}
  .container{display:flex;flex-direction:column;gap:14px}
  .topRow{display:flex;gap:14px;align-items:flex-start;flex-wrap:nowrap}
  .grid-wrap{min-width:300px}
  .board{background:linear-gradient(180deg,#111827,#0b1220);padding:10px;border-radius:8px;box-shadow:0 6px 18px rgba(0,0,0,0.6);min-width:300px;max-width:360px}
  .info-panel{background:linear-gradient(180deg,#07101a,#071421);padding:10px;border-radius:8px;border:1px solid rgba(255,255,255,0.03);display:flex;gap:10px;align-items:flex-start}
  .controls-top{display:flex;justify-content:space-between;align-items:center;margin-bottom:8px;gap:8px}
  .controls-left{display:flex;gap:8px;align-items:center}
  button{background:#2563eb;color:white;border:none;padding:7px 10px;border-radius:8px;cursor:pointer;font-size:13px}
  button.secondary{background:#1f2937;color:var(--accent);border:1px solid rgba(255,255,255,0.03);padding:6px 8px}
  .grid{display:grid;grid-template-columns:repeat(7,46px);grid-auto-rows:46px;gap:6px;margin-bottom:8px;justify-content:center}
  .cell{width:46px;height:46px;border-radius:8px;display:flex;align-items:center;justify-content:center;cursor:pointer;user-select:none;font-size:13px;font-weight:700;position:relative;overflow:hidden}
  .cell.locked{background:#233045;border:1px solid #0f1724;color:#6b7280}
  .cell.unlocked{background:#dbeafe;color:#022c3a;box-shadow:inset 0 -3px 6px rgba(0,0,0,0.06)}
  .cell.placed{color:#022c3a}
  /* Paste into the <style> section of your HTML (near the .cell rules) */
.cell .tile-label {
  width:100%;
  height:100%;
  display:flex;
  flex-direction:column;
  align-items:center;
  justify-content:center;
  padding:2px 2px;
  font-size:12px;
  font-weight:700;
  box-sizing:border-box;
  pointer-events:none; /* keep cell click events intact */
  line-height:1;
}

.tile-label-top {
  font-size:11px;
  color: rgba(0,0,0,0.9);
  align-self:center;
  margin-bottom:2px;
}

.tile-label-bottom {
  font-size:12px;
  color: rgba(0,0,0,0.95);
  align-self:center;
}

/* centered U for unique pieces */
.cell .tile-label-center {
  width:100%;
  height:100%;
  display:flex;
  align-items:center;
  justify-content:center;
  pointer-events:none;
  font-weight:800;
}
  .placed-red{background:linear-gradient(135deg,#fca5a5,#fecaca); color:#3a0a0a}
  .placed-green{background:linear-gradient(135deg,#86efac,#bbf7d0); color:#03210a}
  .placed-blue{background:linear-gradient(135deg,#93c5fd,#bfdbfe); color:#021029}
  .placed-unique{background:linear-gradient(135deg,var(--unique), #ffb86b); color:#2b0f00}
  .outline-rare { box-shadow: inset 0 0 0 3px var(--rare); }
  .outline-epic { box-shadow: inset 0 0 0 3px var(--epic); }
  .outline-super { box-shadow: inset 0 0 0 3px var(--super); }
  .outline-unique { box-shadow: inset 0 0 0 3px rgba(255,156,0,0.45); }

  .extra-highlight { outline: 3px solid var(--highlight); outline-offset: -3px; }

  .palette-wrap{
    display:grid;
    grid-template-columns: repeat(4, 1fr);
    gap:10px;
    align-items:start;
    width:100%;
  }

  .category-card{
    background:linear-gradient(180deg,var(--card),#061018);
    border-radius:8px;
    padding:8px;
    border:1px solid var(--card-border);
    display:flex;
    flex-direction:column;
    min-width:0;
    max-height:640px;
    overflow:hidden;
  }

  .category-head{display:flex;align-items:center;gap:8px;margin-bottom:6px;font-weight:700;color:var(--accent);font-size:13px}
  .category-body{overflow:auto;padding-right:6px;flex:1}
  .dot{width:10px;height:10px;border-radius:50%;display:inline-block}
  .shape-row{display:flex;gap:8px;align-items:center;margin-bottom:6px;padding:4px 2px;border-radius:6px}
  .mini{display:grid;grid-template-columns:repeat(3,12px);grid-auto-rows:12px;gap:2px}
  .mini .mcell{width:12px;height:12px;background:rgba(255,255,255,0.04);border-radius:2px}
  .mini .mcell.on{background:linear-gradient(180deg,#bae6fd,#60a5fa)}
  .shape-id{width:36px;font-size:12px;color:var(--muted);text-align:left}
  .count{display:flex;align-items:center;gap:6px;margin-left:auto}
  .count input{width:40px;font-size:12px;padding:4px;border-radius:6px;border:1px solid #213244;background:#071021;color:var(--accent);text-align:center;height:28px}

  .selected-mini{width:28px;height:28px;display:grid;grid-template-columns:repeat(3,8px);grid-auto-rows:8px;gap:2px;border-radius:4px;overflow:hidden}
  .selected-mini .mcell{width:8px;height:8px;background:rgba(255,255,255,0.04);border-radius:1px}
  .selected-mini .mcell.on{background:rgba(255,255,255,0.85)}

  .selected-mini.unique{width:40px;height:40px;display:grid;grid-template-columns:repeat(5,8px);grid-auto-rows:8px;gap:2px;border-radius:4px;overflow:hidden}
  .selected-mini.unique .mcell{width:8px;height:8px;background:rgba(255,255,255,0.04)}
  .selected-mini.unique .mcell.on{background:rgba(255,255,255,0.95)}

  .included-mini{width:28px;height:28px;display:grid;grid-template-columns:repeat(3,8px);grid-auto-rows:8px;gap:2px;border-radius:4px;overflow:hidden;align-items:center;justify-items:center}
  .included-mini.rare{background:linear-gradient(180deg,#cfe8ff18,var(--rare));}
  .included-mini.epic{background:linear-gradient(180deg,#f7d8ff18,var(--epic));}
  .included-mini.super{background:linear-gradient(180deg,#ffd8d818,var(--super));}
  .included-mini.unique{background:linear-gradient(180deg,rgba(255,156,0,0.12),var(--unique)); width:48px;height:48px;display:grid;grid-template-columns:repeat(5,8px);grid-auto-rows:8px;gap:2px;}
  .included-mini .mcell{width:8px;height:8px;background:rgba(255,255,255,0.12);border-radius:1px}
  .included-mini .mcell.on{background:rgba(255,255,255,0.95)}

  .unique-mini{display:grid;grid-template-columns:repeat(5,12px);grid-auto-rows:12px;gap:2px;border-radius:3px;overflow:hidden;width:70px;height:70px}
  .unique-mini .mcell{width:12px;height:12px;background:rgba(255,255,255,0.04);border-radius:2px}
  .unique-mini .mcell.on{background:linear-gradient(180deg,var(--unique), #ffb86b);}

  .unique-row{display:flex;gap:8px;align-items:center;margin-bottom:8px;padding:6px;border-radius:6px;background:rgba(255,156,0,0.06);border:1px solid rgba(255,156,0,0.06)}

  #cardUnique .category-body { max-height:420px; overflow-y:auto; }
  #cardUnique .category-body::-webkit-scrollbar { width:10px; }
  #cardUnique .category-body::-webkit-scrollbar-track { background: rgba(255,255,255,0.02); border-radius:6px; }
  #cardUnique .category-body::-webkit-scrollbar-thumb { background: rgba(255,156,0,0.22); border-radius:6px; }
  #cardUnique .category-body::-webkit-scrollbar-thumb:hover { background: rgba(255,156,0,0.32); }

  /* Extra placements: rows with up to 4 items each */
  .extra-indicator { margin-top:8px; padding:8px; border-radius:6px; background: linear-gradient(180deg,#071421,#061219); border:1px solid rgba(255,255,255,0.03); color:#cfe8ff; font-size:13px; }
  .extra-list { display:flex; flex-direction:column; gap:8px; margin-top:8px; }
  .extra-row { display:flex; gap:8px; }
  .extra-item { display:flex; flex-direction:column; gap:6px; align-items:center; padding:8px; border-radius:6px; background: rgba(255,255,255,0.02); min-width:84px; }

  .placements{margin-top:8px;font-size:13px;color:var(--accent);max-height:180px;overflow:auto}

  #saveSlots { display:flex; flex-direction:column; gap:8px; }
  .save-slot{display:flex;gap:8px;align-items:center;padding:6px;border-radius:6px;background:rgba(255,255,255,0.01)}
  .save-mini{width:84px;height:84px;background:#071422;border-radius:6px;display:grid;grid-template-columns:repeat(7,1fr);grid-auto-rows:1fr;gap:1px;padding:2px}
  .save-mini .s-cell{background:rgba(255,255,255,0.02);border-radius:2px}
  .save-mini .s-cell.on{background:linear-gradient(180deg,#bae6fd,#60a5fa)}
  .save-meta{flex:1;display:flex;flex-direction:column;gap:6px}
  .save-controls{display:flex;gap:6px}
  .save-input{width:100%;background:#071421;border:1px solid rgba(255,255,255,0.02);color:var(--accent);padding:4px;border-radius:6px}

  .panel-column{display:flex;flex-direction:column;gap:8px;min-width:140px}
  .selected-area{padding:8px;border-radius:8px;background:linear-gradient(180deg,#07101a,#071421);border:1px solid rgba(255,255,255,0.03)}
  .selected-title{display:flex;align-items:center;gap:8px;margin-bottom:6px;color:var(--accent);font-weight:700}
  .selected-sets{display:flex;gap:8px}
  .selected-set{flex:1;padding:8px;border-radius:8px;background:rgba(255,255,255,0.02);min-height:64px;display:flex;flex-direction:column;gap:6px}
  .selected-list{display:flex;flex-direction:row;flex-wrap:wrap;gap:8px;align-items:center}
  .selected-item{display:flex;flex-direction:row;gap:6px;align-items:center;padding:4px;border-radius:6px;cursor:pointer;user-select:none;font-size:13px;flex:0 0 auto}
  .selected-item.rare { background: var(--rare); color: #021029; }
  .selected-item.epic { background: var(--epic); color: #fff; }
  .selected-item.super { background: var(--super); color: #fff; }
  .selected-item.unique { background: linear-gradient(90deg,var(--unique),#ffb86b); color:#2b0f00; border:2px solid rgba(0,0,0,0.15); padding:6px; }

  .included-area{padding:8px;border-radius:8px;background:linear-gradient(180deg,#06111a,#061216);border:1px solid rgba(255,255,255,0.02)}
  .included-sets{display:flex;gap:8px}
  .included-set{flex:1;padding:8px;border-radius:8px;background:rgba(255,255,255,0.02);min-height:64px;display:flex;flex-direction:column;gap:6px}
  .included-list{display:flex;flex-direction:row;flex-wrap:wrap;gap:8px;align-items:center}
  .included-item{display:flex;flex-direction:row;gap:8px;align-items:center;padding:4px;border-radius:6px;font-size:13px;flex:0 0 auto}

  /* New helper classes to enforce 4-per-row layout in the selected/included panes */
  .items-rows { display:flex; flex-direction:column; gap:8px; }
  .items-row { display:flex; gap:8px; }

  .scoreboard { width:100%; border-collapse:collapse; font-size:13px; color:var(--accent); margin-bottom:8px }
  .scoreboard th, .scoreboard td { border:1px solid rgba(255,255,255,0.04); padding:6px 8px; text-align:center; }
  .scoreboard .colheader { font-weight:700; }

  @media (max-width:1200px){
    .palette-wrap{grid-template-columns: repeat(2, 1fr); }
  }
  @media (max-width:720px){
    .palette-wrap{grid-template-columns: 1fr; }
    .topRow{flex-direction:column;}
  }
</style>
</head>
<body>
<h1>CR:TOA Rift Resistance Optimizer</h1>

<div class="container">
  <div class="topRow">
    <div class="grid-wrap">
      <div class="board">
        <div class="controls-top">
          <div class="controls-left">
            <div style="color:#9fb6d4;font-size:12px">Click cells to toggle locked/unlocked</div>
            <div id="unlockedCounter" style="color:#9fb6d4;font-size:12px;margin-left:8px">Unlocked: 0</div>
          </div>
          <div style="display:flex;gap:8px;align-items:center">
            <div>
              <button id="solveBtn">Solve (maximize Total)</button>
              <button id="resetGrid" class="secondary">Reset</button>
              <button id="clearAll" class="secondary">Clear</button>
            </div>
            <div style="display:flex;flex-direction:column;gap:4px;margin-left:8px">
              <div style="color:#9fb6d4;font-size:12px;text-align:right">Active Set</div>
              <div style="display:flex;gap:6px">
                <button id="selectSet1" class="secondary" aria-pressed="true">Set 1</button>
                <button id="selectSet2" class="secondary" aria-pressed="false">Set 2</button>
              </div>
            </div>
          </div>
        </div>

        <div id="grid" class="grid" title="Click to toggle locked/unlocked"></div>

        <div class="placements" id="placements"></div>
      </div>
    </div>

    <div id="infoPanel" class="info-panel row" aria-label="Selection and Scoreboard panel">
      <div class="panel-column" id="selectedPanel">
        <div class="selected-area">
          <div class="selected-title">
            <span style="width:10px;height:10px;border-radius:50%;background:var(--rare);display:inline-block;"></span>
            <div>Shapes selected <span style="color:#9fb6d4;font-weight:400;margin-left:8px;font-size:12px">(click mini -> cycle rarity, right-click to delete, drag between sets)</span></div>
          </div>

          <div style="display:flex;flex-direction:column;gap:8px;margin-bottom:8px">
            <div style="display:flex;align-items:center;gap:8px">
              <label style="font-size:13px;color:#9fb6d4;display:flex;align-items:center;gap:8px">
                <input type="checkbox" id="includeUniqueToggle" /> Include a Unique shape
              </label>
              <div id="uniqueChosenIndicator" style="color:#9fb6d4;font-size:13px;margin-left:auto">None chosen</div>
            </div>

            <div class="selected-sets">
              <div class="selected-set" style="min-width:160px">
                <div class="selected-set-header" style="display:flex;justify-content:space-between;align-items:center"><div>Set 1</div><div id="set1Count" style="color:#9fb6d4;font-weight:700">0</div></div>
                <div id="set1" class="selected-list" ondragover="event.preventDefault()"></div>
              </div>

              <div class="selected-set" style="min-width:160px">
                <div class="selected-set-header" style="display:flex;justify-content:space-between;align-items:center"><div>Set 2</div><div id="set2Count" style="color:#9fb6d4;font-weight:700">0</div></div>
                <div id="set2" class="selected-list" ondragover="event.preventDefault()"></div>
              </div>
            </div>

            <div id="uniqueSelectedContainer" style="margin-top:6px; display:none;">
              <div style="font-weight:700;color:var(--muted);margin-bottom:6px">Unique (selected)</div>
              <div class="selected-set" style="min-height:64px; background: rgba(255,156,0,0.02);">
                <div id="uniqueSelectedBox" class="selected-list" style="min-height:48px;align-items:center"></div>
              </div>
            </div>
          </div>
        </div>
      </div>

      <div class="panel-column" id="includedPanel">
        <div class="included-area" id="includedArea">
          <div class="included-title">
            <span style="width:10px;height:10px;border-radius:50%;background:#9fb6d4;display:inline-block;"></span>
            <div>Shapes included in the current solution</div>
          </div>

          <div class="included-sets">
            <div class="included-set">
              <div style="font-weight:700;color:var(--muted);display:flex;justify-content:space-between"><div>Set 1</div><div id="includedSet1Tiles" style="color:#9fb6d4">Tiles: 0</div></div>
              <div id="includedListSet1" class="included-list"></div>
            </div>
            <div class="included-set">
              <div style="font-weight:700;color:var(--muted);display:flex;justify-content:space-between"><div>Set 2</div><div id="includedSet2Tiles" style="color:#9fb6d4">Tiles: 0</div></div>
              <div id="includedListSet2" class="included-list"></div>
            </div>
          </div>

          <div id="includedUniqueContainer" style="margin-top:8px; display:none;">
            <div style="font-weight:700;color:var(--muted);margin-bottom:6px;display:flex;justify-content:space-between"><div>Unique (selected)</div><div id="includedUniqueTiles" style="color:#9fb6d4">Tiles: 0</div></div>
            <div class="included-set" style="margin-top:0; padding:8px; background: rgba(255,156,0,0.02);">
              <div id="includedListUnique" class="included-list"></div>
            </div>
          </div>

          <div id="extraIndicator" class="extra-indicator" style="display:none;">
            <div id="extraHeader"></div>
            <div id="extraList" class="extra-list"></div>
          </div>
        </div>
      </div>

      <div class="panel-column" id="scoreAndSaves" style="min-width:260px">
        <table class="scoreboard" id="scoreboard" aria-label="Rift Resistance scoreboard">
          <thead>
            <tr>
              <th class="colheader">Metric</th>
              <th class="colheader" style="background:var(--rare);color:#021029">Rare</th>
              <th class="colheader" style="background:var(--epic);">Epic</th>
              <th class="colheader" style="background:var(--super);">Super Epic</th>
            </tr>
          </thead>
          <tbody>
            <tr><td>Tiles (Set 1)</td><td id="sb_tiles1_rare">0</td><td id="sb_tiles1_epic">0</td><td id="sb_tiles1_super">0</td></tr>
            <tr><td>Rift Resistance (Set 1)</td><td id="sb_rr1_rare">0</td><td id="sb_rr1_epic">0</td><td id="sb_rr1_super">0</td></tr>
            <tr><td>Set Bonus (Set 1)</td><td id="sb_set1_rare">0</td><td id="sb_set1_epic">0</td><td id="sb_set1_super">0</td></tr>

            <tr><td>Tiles (Set 2)</td><td id="sb_tiles2_rare">0</td><td id="sb_tiles2_epic">0</td><td id="sb_tiles2_super">0</td></tr>
            <tr><td>Rift Resistance (Set 2)</td><td id="sb_rr2_rare">0</td><td id="sb_rr2_epic">0</td><td id="sb_rr2_super">0</td></tr>
            <tr><td>Set Bonus (Set 2)</td><td id="sb_set2_rare">0</td><td id="sb_set2_epic">0</td><td id="sb_set2_super">0</td></tr>
          </tbody>
        </table>

        <div style="margin-bottom:8px">
          <div style="font-weight:700;color:var(--muted);margin-bottom:6px">Dual Set Bonus</div>
          <select id="dualSetBonus" disabled style="width:100%;padding:6px;border-radius:6px;background:#071421;color:var(--accent);border:1px solid rgba(255,255,255,0.02)">
            <option value="none">None</option>
          </select>
          <div id="dualSetHelp" style="font-size:12px;color:#9fb6d4;margin-top:6px">Locked — enable by unlocking at least 24 tiles.</div>
        </div>

        <div class="saves-area" id="savesArea">
          <div style="font-weight:700;color:var(--muted);margin-bottom:6px">Saved solutions (local)</div>
          <div id="saveSlots"></div>
        </div>
      </div>
    </div>
  </div>

  <div class="palette-wrap" id="paletteWrap">
    <div class="category-card" id="cardSmall">
      <div class="category-head"><span class="dot red"></span><div style="margin-left:6px">1–3 tiles</div></div>
      <div class="category-body" id="colA"></div>
    </div>

    <div class="category-card" id="card4">
      <div class="category-head"><span class="dot green"></span><div style="margin-left:6px">4 tiles</div></div>
      <div class="category-body" id="colB"></div>
    </div>

    <div class="category-card" id="card5">
      <div class="category-head"><span class="dot blue"></span><div style="margin-left:6px">5 tiles</div></div>
      <div class="category-body" id="colC"></div>
    </div>

    <div class="category-card" id="cardUnique" style="display:none">
      <div class="category-head"><span class="dot" style="background:var(--unique)"></span><div style="margin-left:6px">Unique (8 tiles) — choose 1</div></div>
      <div class="category-body" id="colUnique"></div>
    </div>
  </div>
</div>

  <section class="devlog-box" style="margin-top:24px; max-width:820px;">
  <div class="devlog-header" style="background:linear-gradient(90deg,#233045,#2563eb);color:#fff;font-weight:700;font-size:15px;padding:10px 12px 8px 12px;border-radius:8px 8px 0 0;">
    Devlog
  </div>
  <div class="devlog-body" style="background:linear-gradient(180deg,#1e293b,#071421 60%);color:#cfe8ff;font-size:14px;padding:16px 14px 20px 14px;border-radius:0 0 8px 8px;border:1px solid #233045;">
    <strong>2024-06-15</strong> – Added Devlog box!  
    <ul>
      <li>I'm just gonna be straight-forward, this whole site was literally built by nothing but AI and constant testing to make sure everything works out, the only thing I can't get right however is the algorithm, some find it to be working, some don't. So please, I beg of users who truly appreciate the time I wasted to make this site out of pure spite and frustration towards CR:TOA's current state, to use this more of a template or a testing ground rather than a perfect tool that you can do however you want with it and expect perfect results. If you want any small additional QoL changes made to the site (do not come complaining to me about the algorithm), ping or DM me anytime. - LazyGuardian</li>
      <li>Edit directly in the HTML: find <code>devlog-body</code> and change anything you want!</li>
      <li>This box is not affected by JavaScript or app resets.</li>
    </ul>
    <!--
      To update the Devlog: Only change this HTML! Add new sections, write markdown-style lists, etc.
    -->
  </div>
</section>

<script>
/* Final consolidated single-file app with requested fixes:
   - Reset and Clear behavior fixed (Reset -> default unlocked center + clear selections & solution; Clear -> clear selections & solution but keep unlocked)
   - Set 1 selected by default via setActiveSet(1)
   - "Additional placements possible" rows limited to 4 shapes each
   - Shape IDs removed from visible mini-previews in Shapes selected (kept as title on element)
   - All previous robustness, save/load, Unique handling kept
   - When shapes are shown on grid, the tiles show S-1 or S-2 depending on set (displayLabel), while pid remains unique for internal grouping and save/load
   - Tetromino-I transforms are explicitly ordered and given preview overrides so S10 = horizontal (1x4) and S11 = vertical (4x1)
*/

const USER_KEY = 'hoangnh1630-rgb';
const SAVES_KEY = `polyomino_saves_${USER_KEY}_v1`;
const ROWS = 7, COLS = 7;
const RARITY_VALUES = { rare: 30, epic: 60, super: 120, unique: 2000 };
const SET_THRESHOLDS = [0,9,12,15,18,21];

// App state
window.unlocked = Array.from({length:ROWS}, ()=>Array.from({length:COLS}, ()=>false));
window.shapeTypes = [];
window.uniqueTypes = [];
window.selectedInstances = [];
window.placedCells = {};
window.hasSolution = false;
window.activeSet = 1;
window.includeUnique = false;
window.currentUniqueIid = null;
window.nextInstanceId = 1;

// DOM refs
const gridEl = document.getElementById('grid');
const colA = document.getElementById('colA');
const colB = document.getElementById('colB');
const colC = document.getElementById('colC');
const colUnique = document.getElementById('colUnique');
const set1ListEl = document.getElementById('set1');
const set2ListEl = document.getElementById('set2');
const uniqueSelectedBox = document.getElementById('uniqueSelectedBox');
const uniqueSelectedContainer = document.getElementById('uniqueSelectedContainer');
const includedListSet1El = document.getElementById('includedListSet1');
const includedListSet2El = document.getElementById('includedListSet2');
const includedListUniqueEl = document.getElementById('includedListUnique');
const includedUniqueContainer = document.getElementById('includedUniqueContainer');
const includedSet1TilesEl = document.getElementById('includedSet1Tiles');
const includedSet2TilesEl = document.getElementById('includedSet2Tiles');
const includedUniqueTilesEl = document.getElementById('includedUniqueTiles');
const placementsEl = document.getElementById('placements');
const extraIndicatorEl = document.getElementById('extraIndicator');
const extraHeaderEl = document.getElementById('extraHeader');
const extraListEl = document.getElementById('extraList');
const set1CountEl = document.getElementById('set1Count');
const set2CountEl = document.getElementById('set2Count');
const unlockedCounterEl = document.getElementById('unlockedCounter');
const selectSet1Btn = document.getElementById('selectSet1');
const selectSet2Btn = document.getElementById('selectSet2');
const saveSlotsContainer = document.getElementById('saveSlots');
const dualSetSelect = document.getElementById('dualSetBonus');
const dualSetHelp = document.getElementById('dualSetHelp');
const includeUniqueToggle = document.getElementById('includeUniqueToggle');
const cardUnique = document.getElementById('cardUnique');
const uniqueChosenIndicator = document.getElementById('uniqueChosenIndicator');

// Geometry helpers
function normalize(cells){
  if(!cells || cells.length===0) return [];
  const minr = Math.min(...cells.map(p=>p[0]));
  const minc = Math.min(...cells.map(p=>p[1]));
  return cells.map(p=>[p[0]-minr, p[1]-minc]).sort((a,b)=>a[0]-b[0]||a[1]-b[1]);
}
function rotate90(cells){ return normalize(cells.map(([r,c])=>[c,-r])); }
function reflectX(cells){ return normalize(cells.map(([r,c])=>[-r,c])); }
function all8_unique(cells){
  const t0 = normalize(cells);
  const raw=[];
  let cur=t0;
  for(let i=0;i<4;i++){ raw.push(cur); cur=rotate90(cur); }
  cur=reflectX(t0);
  for(let i=0;i<4;i++){ raw.push(cur); cur=rotate90(cur); }
  const seen=new Set(), out=[];
  for(const t of raw){
    const key = t.map(p=>p[0]+','+p[1]).join(';');
    if(!seen.has(key)){ seen.add(key); out.push(t); }
  }
  return out;
}

// Shapes
const baseShapes = [
  {name:"monomino", cells:[[0,0]]},
  {name:"domino", cells:[[0,0],[0,1]]},
  {name:"tromino-I", cells:[[0,0],[0,1],[0,2]]},
  {name:"tromino-L", cells:[[0,0],[0,1],[1,0]]},
  // tetromino-I is handled specially so we can ensure S10 and S11 previews/orientations
  {name:"tetromino-I", cells:[[0,0],[0,1],[0,2],[0,3]]},
  {name:"tetromino-O", cells:[[0,0],[0,1],[1,0],[1,1]]},
  {name:"tetromino-T", cells:[[0,1],[1,0],[1,1],[1,2]]},
  {name:"tetromino-L", cells:[[0,0],[1,0],[2,0],[2,1]]},
  {name:"pentomino-T", cells:[[0,0],[0,1],[0,2],[1,1],[2,1]]},
  {name:"pentomino-U", cells:[[0,0],[0,2],[1,0],[1,1],[1,2]]},
  {name:"pentomino-V", cells:[[0,0],[1,0],[2,0],[2,1],[2,2]]},
  {name:"pentomino-X", cells:[[0,1],[1,0],[1,1],[1,2],[2,1]]},
  {name:"pentomino-Z", cells:[[0,0],[0,1],[1,1],[2,1],[2,2]]},
];
const baseUniqueShapes = [
  { name: "U1", rows: ["X.","XX","XX","XX",".X"] },
  { name: "U2", rows: [".XX.",".XX.","XXXX"] },
  { name: "U3", rows: ["XXXX","XXXX"] },
  { name: "U4", rows: [".X.","XXX","XXX",".X."] },
  { name: "U5", rows: ["XXXX",".XX.",".XX."] },
  { name: "U6", rows: [".XX.","XXXX",".XX."] },
  { name: "U7", rows: [".XXXX","XXXX."] },
  { name: "U8", rows: ["XX","XX","XX","XX"] }
];
function rowsToCells(rows){
  const cells = [];
  for(let r=0;r<rows.length;r++){
    const row = rows[r];
    for(let c=0;c<row.length;c++){
      if(row[c] === 'X') cells.push([r,c]);
    }
  }
  return normalize(cells);
}
function buildShapeTypes(){
  window.shapeTypes = [];
  let sid = 1;
  for(const b of baseShapes){
    // special-case tetromino-I so we assign its two orientations explicitly and attach preview overrides
    if(b.name === 'tetromino-I'){
      // horizontal 1x4
      const horiz = normalize([[0,0],[0,1],[0,2],[0,3]]);
      window.shapeTypes.push({ id: 'S'+sid, cells: horiz, baseName: b.name, size: horiz.length, preview: { cols: 4, rows: 1 } });
      sid++;
      // vertical 4x1
      const vert = normalize([[0,0],[1,0],[2,0],[3,0]]);
      window.shapeTypes.push({ id: 'S'+sid, cells: vert, baseName: b.name, size: vert.length, preview: { cols: 1, rows: 4 } });
      sid++;
      continue;
    }

    const transforms = all8_unique(b.cells);
    for(const t of transforms){
      window.shapeTypes.push({ id: 'S'+sid, cells: t, baseName: b.name, size: t.length });
      sid++;
    }
  }
}
function buildUniqueTypes(){
  window.uniqueTypes = [];
  let uid = 1;
  for(const b of baseUniqueShapes){
    const cells = rowsToCells(b.rows);
    const transforms = all8_unique(cells);
    for(const t of transforms){
      window.uniqueTypes.push({ id: 'U'+uid, cells: t, baseName: b.name, size: t.length });
      uid++;
    }
  }
}

/* ---------- UI renderers ---------- */

function updateUnlockedCounter(){ let cnt=0; for(let r=0;r<ROWS;r++) for(let c=0;c<COLS;c++) if(window.unlocked[r][c]) cnt++; unlockedCounterEl.textContent=`Unlocked: ${cnt}`; }

// Replace the existing `function renderGrid(){ ... }` in the <script> with this version.
// It shows "set index" on the left and "piece index" on the right (e.g., "1" and "3") for non-unique pieces.
// Unique pieces show a single centered "U" and are not split.

// Replace your existing function renderGrid() with this version.
// Top shows "S-#" (set label), bottom shows "P#" (piece index). Unique remains centered "U".
function renderGrid(){
  gridEl.innerHTML = '';
  for(let r=0;r<ROWS;r++){
    for(let c=0;c<COLS;c++){
      const div = document.createElement('div');
      const k = r+','+c;
      const placed = window.placedCells[k];

      div.className = 'cell ' + (placed ? 'placed' : (window.unlocked[r][c] ? 'unlocked' : 'locked'));

      if(placed){
        // preserve existing color / outline classes
        if(placed.colorClass) div.classList.add(placed.colorClass);
        if(placed.rarity === 'rare') div.classList.add('outline-rare');
        else if(placed.rarity === 'epic') div.classList.add('outline-epic');
        else if(placed.rarity === 'super') div.classList.add('outline-super');
        else if(placed.rarity === 'unique') div.classList.add('outline-unique');

        div.dataset.rarity = placed.rarity;

        if(placed.rarity === 'unique'){
          // Unique pieces: centered "U"
          const center = document.createElement('div');
          center.className = 'tile-label-center';
          center.textContent = 'U';
          div.appendChild(center);
        } else {
          // Non-unique: top = "S-#", bottom = "P#"

          // Assemble set label "S-#" when set is known (1 or 2)
          let setLabel = '';
          if(typeof placed.set === 'number' && (placed.set === 1 || placed.set === 2)){
            setLabel = `S-${placed.set}`;
          } else if(placed.displayLabel && placed.displayLabel.startsWith('S-')){
            // fallback if displayLabel contains S-#
            setLabel = placed.displayLabel;
          }

          // Piece index: prefer placed.pid (P#). If pid missing or not P#, try iid numeric -> P#
          let pieceLabel = '';
          if(placed.pid){
            const m = (''+placed.pid).match(/^P(\d+)$/i);
            if(m){
              pieceLabel = `P${m[1]}`;
            } else {
              // if pid is not a plain P# (maybe stored differently), use it directly
              pieceLabel = placed.pid;
            }
          }
          if(!pieceLabel && placed.iid){
            const m2 = (''+placed.iid).match(/^I(\d+)$/i);
            if(m2) pieceLabel = `P${m2[1]}`;
          }
          pieceLabel = pieceLabel || '';

          // Build vertical label wrapper
          const wrapper = document.createElement('div');
          wrapper.className = 'tile-label';

          const top = document.createElement('div');
          top.className = 'tile-label-top';
          top.textContent = setLabel;

          const bottom = document.createElement('div');
          bottom.className = 'tile-label-bottom';
          bottom.textContent = pieceLabel;

          wrapper.appendChild(top);
          wrapper.appendChild(bottom);
          div.appendChild(wrapper);
        }
      } else {
        div.textContent = '';
      }

      div.dataset.rc = k;
      div.title = placed ? `Placed ${placed && (placed.displayLabel || placed.pid) ? (placed.displayLabel || placed.pid) : ''} (set ${placed && placed.set ? placed.set : ''})` : (window.unlocked[r][c] ? 'Unlocked' : 'Locked');
      div.addEventListener('click', ()=> {
        if(window.hasSolution) clearSolution();
        window.unlocked[r][c] = !window.unlocked[r][c];
        renderGrid(); updateUnlockedCounter(); updateDualSetBonusOptions(); updateExtraIndicator();
      });
      gridEl.appendChild(div);
    }
  }
  updateUnlockedCounter();
}

/* Selected list */
function countInstancesOfShape(shapeId){ return window.selectedInstances.filter(s=>s.shapeId===shapeId).length; }
function addInstance(shapeId, size, baseName){
  const iid = 'I' + (window.nextInstanceId++);
  window.selectedInstances.push({ iid, shapeId, rarity:'rare', size, baseName, set: window.activeSet });
}
function removeOneInstanceOfShape(shapeId){
  for(let i=window.selectedInstances.length-1;i>=0;i--){
    if(window.selectedInstances[i].shapeId === shapeId){
      if(window.selectedInstances[i].rarity === 'unique') window.currentUniqueIid = null;
      window.selectedInstances.splice(i,1); return;
    }
  }
}
function setInstancesCountForShape(shapeId, targetCount, size, baseName){
  const cur = window.selectedInstances.filter(s=>s.shapeId===shapeId && s.rarity!=='unique').length;
  if(targetCount > cur){
    for(let i=0;i<targetCount-cur;i++) addInstance(shapeId,size,baseName);
  } else if(targetCount < cur){
    let removed = 0;
    for(let i=window.selectedInstances.length-1;i>=0 && removed < (cur-targetCount); i--){
      if(window.selectedInstances[i].shapeId === shapeId && window.selectedInstances[i].rarity!=='unique'){ window.selectedInstances.splice(i,1); removed++; }
    }
  }
}
function chooseUniqueBase(baseName){
  const rep = window.uniqueTypes.find(u => u.baseName === baseName);
  if(!rep) return;
  for(let i=window.selectedInstances.length-1;i>=0;i--){
    if(window.selectedInstances[i].rarity === 'unique'){ window.selectedInstances.splice(i,1); }
  }
  const iid = 'I' + (window.nextInstanceId++);
  window.selectedInstances.push({ iid, shapeId: baseName, rarity:'unique', size: rep.size, baseName, set: 0, cells: rep.cells });
  window.currentUniqueIid = iid;
}

function renderPalette(){
  colA.innerHTML=''; colB.innerHTML=''; colC.innerHTML=''; colUnique.innerHTML='';
  const cats = { small:[], four:[], five:[], other:[] };
  for(const s of window.shapeTypes){
    if(s.size<=3) cats.small.push(s);
    else if(s.size===4) cats.four.push(s);
    else if(s.size===5) cats.five.push(s);
    else cats.other.push(s);
  }
  function makeRow(s){
    const row = document.createElement('div'); row.className='shape-row';
    const mini = document.createElement('div'); mini.className='mini';
    // Allow preview override (used for S10 / S11 tetromino-I horizont/vertical)
    const maxR = s.cells.length ? Math.max(...s.cells.map(p=>p[0])) : 0;
    const maxC = s.cells.length ? Math.max(...s.cells.map(p=>p[1])) : 0;
    const h = s.preview ? Math.max(1, s.preview.rows) : Math.max(1, Math.min(3, maxR+1));
    const w = s.preview ? Math.max(1, s.preview.cols) : Math.max(1, Math.min(3, maxC+1));
    mini.style.gridTemplateColumns = `repeat(${w},12px)`;
    for(let rr=0; rr<h; rr++){
      for(let cc=0; cc<w; cc++){
        const mc = document.createElement('div'); mc.className='mcell';
        if(s.cells.some(p=>p[0]===rr && p[1]===cc)) mc.classList.add('on');
        mini.appendChild(mc);
      }
    }
    const idEl = document.createElement('div'); idEl.className='shape-id'; idEl.textContent = s.id;
    const countWrap = document.createElement('div'); countWrap.className='count';
    const minus = document.createElement('button'); minus.textContent='-'; minus.style.padding='3px 6px';
    const inp = document.createElement('input'); inp.type='number'; inp.min='0'; inp.value = countInstancesOfShape(s.id);
    const plus = document.createElement('button'); plus.textContent='+'; plus.style.padding='3px 6px';
    minus.addEventListener('click', ()=>{
      removeOneInstanceOfShape(s.id);
      inp.value = countInstancesOfShape(s.id);
      renderSelectedList(); updateExtraIndicator();
    });
    plus.addEventListener('click', ()=>{
      addInstance(s.id, s.size, s.baseName);
      inp.value = countInstancesOfShape(s.id);
      renderSelectedList(); updateExtraIndicator();
    });
    inp.addEventListener('change', ()=>{
      let v = parseInt(inp.value||0); if(isNaN(v)||v<0) v=0;
      setInstancesCountForShape(s.id, v, s.size, s.baseName);
      inp.value = countInstancesOfShape(s.id);
      renderSelectedList(); updateExtraIndicator();
    });
    countWrap.appendChild(minus); countWrap.appendChild(inp); countWrap.appendChild(plus);
    row.appendChild(mini); row.appendChild(idEl); row.appendChild(countWrap);
    return row;
  }
  if(cats.small.length) cats.small.forEach(s=>colA.appendChild(makeRow(s))); else colA.innerHTML='<div style="color:#9fb6d4">No shapes</div>';
  if(cats.four.length) cats.four.forEach(s=>colB.appendChild(makeRow(s))); else colB.innerHTML='<div style="color:#9fb6d4">No shapes</div>';
  if(cats.five.length || cats.other.length){
    cats.five.forEach(s=>colC.appendChild(makeRow(s)));
    cats.other.forEach(s=>colC.appendChild(makeRow(s)));
  } else colC.innerHTML='<div style="color:#9fb6d4">No shapes</div>';

  if(window.includeUnique){
    cardUnique.style.display = 'block';
    if(window.uniqueTypes.length===0) {
      colUnique.innerHTML = '<div style="color:#9fb6d4">No unique shapes</div>';
    } else {
      colUnique.innerHTML = '';
      const baseMap = {};
      for(const ut of window.uniqueTypes){
        const base = ut.baseName || ut.id;
        if(!baseMap[base]) baseMap[base] = ut;
      }
      Object.keys(baseMap).sort().forEach(baseId => {
        const u = baseMap[baseId];
        const row = document.createElement('div'); row.className = 'unique-row';
        const mini = document.createElement('div'); mini.className = 'unique-mini';
        for(let rr=0; rr<5; rr++){
          for(let cc=0; cc<5; cc++){
            const mc = document.createElement('div'); mc.className='mcell';
            if(u.cells.some(q=>q[0]===rr && q[1]===cc)) mc.classList.add('on');
            mini.appendChild(mc);
          }
        }
        const idEl = document.createElement('div'); idEl.className='shape-id'; idEl.textContent = u.baseName;
        const selBtn = document.createElement('button'); selBtn.textContent = (window.currentUniqueIid && window.selectedInstances.find(si=>si.iid===window.currentUniqueIid && si.baseName===u.baseName)) ? 'Chosen' : 'Select';
        selBtn.style.background = 'linear-gradient(90deg,var(--unique),#ffb86b)'; selBtn.style.border='none'; selBtn.style.color='#2b0f00';
        selBtn.addEventListener('click', ()=>{
          chooseUniqueBase(u.baseName);
          renderPalette(); renderSelectedList(); updateUniqueContainersVisibility();
        });
        row.appendChild(mini); row.appendChild(idEl); row.appendChild(selBtn);
        colUnique.appendChild(row);
      });
    }
  } else {
    cardUnique.style.display = 'none';
  }
}

/* Selected list renderer — shape id label removed; id kept as title attribute
   Modified to limit Set 1 and Set 2 displays to rows with up to 4 items per row (row-by-row stacking).
*/
function renderSelectedList(){
  set1ListEl.innerHTML = ''; set2ListEl.innerHTML = ''; uniqueSelectedBox.innerHTML = '';
  if(window.selectedInstances.length===0){
    set1ListEl.innerHTML = '<div style="color:#9fb6d4">No shapes selected</div>';
    set2ListEl.innerHTML = '<div style="color:#9fb6d4">No shapes selected</div>';
    uniqueSelectedBox.innerHTML = '<div style="color:#9fb6d4">No Unique selected</div>';
    set1CountEl.textContent='0'; set2CountEl.textContent='0'; updateUniqueContainersVisibility(); return;
  }
  const s1 = window.selectedInstances.filter(x=>x.set===1 && x.rarity!=='unique');
  const s2 = window.selectedInstances.filter(x=>x.set===2 && x.rarity!=='unique');
  const su = window.selectedInstances.filter(x=>x.rarity==='unique');
  set1CountEl.textContent = s1.length; set2CountEl.textContent = s2.length;

  function createItem(inst){
    const item = document.createElement('div'); item.className = 'selected-item ' + inst.rarity;
    item.draggable = (inst.rarity !== 'unique');
    item.dataset.iid = inst.iid;

    // mini grid only, no textual id label
    const st = window.shapeTypes.find(s=>s.id===inst.shapeId) || window.uniqueTypes.find(s=>s.baseName===inst.shapeId) || window.uniqueTypes.find(s=>s.id===inst.shapeId);
    const cells = (inst.rarity==='unique' && inst.cells) ? inst.cells : (st ? st.cells : [[0,0]]);
    const maxR = cells.length ? Math.max(...cells.map(p=>p[0])) : 0;
    const maxC = cells.length ? Math.max(...cells.map(p=>p[1])) : 0;
    // use preview override if present (so S10/S11 show 1x4 or 4x1 exactly)
    const gridCols = (inst.rarity==='unique') ? 5 : (st && st.preview ? Math.max(1, st.preview.cols) : Math.max(1, Math.min(4, maxC+1)));
    const gridRows = (inst.rarity==='unique') ? 5 : (st && st.preview ? Math.max(1, st.preview.rows) : Math.max(1, Math.min(4, maxR+1)));

    const mini = document.createElement('div'); mini.className = 'selected-mini' + (inst.rarity==='unique' ? ' unique' : '');
    mini.style.gridTemplateColumns = `repeat(${gridCols},8px)`;
    mini.style.gridAutoRows = `8px`;
    mini.innerHTML = '';
    for(let rr=0; rr<gridRows; rr++){
      for(let cc=0; cc<gridCols; cc++){
        const mc = document.createElement('div'); mc.className='mcell';
        if(cells.some(q=>q[0]===rr && q[1]===cc)) mc.classList.add('on');
        mini.appendChild(mc);
      }
    }
    item.appendChild(mini);

    // use title attribute so screen readers / hover show id, but don't display it visually
    item.title = inst.shapeId;

    item.addEventListener('click', (ev)=>{ ev.preventDefault(); if(inst.rarity !== 'unique'){ cycleRarityForInstance(inst.iid); } renderSelectedList(); });
    item.addEventListener('contextmenu', (ev)=>{ ev.preventDefault(); const idx = window.selectedInstances.findIndex(x=>x.iid===inst.iid); if(idx>=0) { if(window.selectedInstances[idx].rarity === 'unique') window.currentUniqueIid = null; window.selectedInstances.splice(idx,1); } renderSelectedList(); renderPalette(); updateExtraIndicator(); updateUniqueContainersVisibility(); });
    item.addEventListener('dragstart', (ev)=> onDragStart(ev, inst.iid));

    return item;
  }

  function appendItemsAsRows(containerEl, itemsArr, createFn){
    containerEl.innerHTML = '';
    if(!itemsArr || itemsArr.length===0){
      containerEl.innerHTML = '<div style="color:#9fb6d4">No shapes selected</div>';
      return;
    }
    const perRow = 4;
    const rowsWrap = document.createElement('div');
    rowsWrap.className = 'items-rows';
    for(let i=0;i<itemsArr.length;i+=perRow){
      const rowDiv = document.createElement('div');
      rowDiv.className = 'items-row';
      for(let j=i;j<i+perRow && j<itemsArr.length;j++){
        const node = createFn(itemsArr[j]);
        rowDiv.appendChild(node);
      }
      rowsWrap.appendChild(rowDiv);
    }
    containerEl.appendChild(rowsWrap);
  }

  appendItemsAsRows(set1ListEl, s1, createItem);
  appendItemsAsRows(set2ListEl, s2, createItem);

  if(su.length) su.forEach(inst => uniqueSelectedBox.appendChild(createItem(inst))); else uniqueSelectedBox.innerHTML = '<div style="color:#9fb6d4">No Unique selected</div>';

  set1ListEl.ondragover = (ev)=>{ ev.preventDefault(); set1ListEl.classList.add('droppable-over'); };
  set1ListEl.ondragleave = ()=> set1ListEl.classList.remove('droppable-over');
  set1ListEl.ondrop = (ev)=>{ set1ListEl.classList.remove('droppable-over'); onDropToSet(ev,1); };

  set2ListEl.ondragover = (ev)=>{ ev.preventDefault(); set2ListEl.classList.add('droppable-over'); };
  set2ListEl.ondragleave = ()=> set2ListEl.classList.remove('droppable-over');
  set2ListEl.ondrop = (ev)=>{ set2ListEl.classList.remove('droppable-over'); onDropToSet(ev,2); };

  updatePaletteInputs();
  updateUniqueContainersVisibility();
}

function cycleRarityForInstance(iid){
  const inst = window.selectedInstances.find(x=>x.iid===iid);
  if(!inst) return;
  if(inst.rarity === 'unique') return;
  const order = ['rare','epic','super'];
  const idx = order.indexOf(inst.rarity);
  inst.rarity = order[(idx+1) % order.length];
}
function updatePaletteInputs(){
  document.querySelectorAll('.category-body input[type="number"]').forEach(inp=>{
    const row = inp.closest('.shape-row'); if(!row) return;
    const idEl = row.querySelector('.shape-id'); if(!idEl) return;
    inp.value = countInstancesOfShape(idEl.textContent);
  });
}

// Drag/drop helpers
function onDragStart(ev, iid){ ev.dataTransfer.setData('text/plain', iid); ev.dataTransfer.effectAllowed = 'move'; }
function onDropToSet(ev, setNum){
  ev.preventDefault();
  const iid = ev.dataTransfer.getData('text/plain');
  const inst = window.selectedInstances.find(x=>x.iid===iid);
  if(inst){
    if(inst.rarity === 'unique') return;
    inst.set = setNum; renderSelectedList();
  }
}

/* Included list */
function renderIncludedList(placements){
  includedListSet1El.innerHTML = ''; includedListSet2El.innerHTML = ''; includedListUniqueEl.innerHTML = '';
  if(!placements || placements.length===0){
    includedListSet1El.innerHTML = '<div style="color:#9fb6d4">No shapes in current solution</div>';
    includedListSet2El.innerHTML = '<div style="color:#9fb6d4">No shapes in current solution</div>';
    includedListUniqueEl.innerHTML = '<div style="color:#9fb6d4">No Unique included</div>';
    includedSet1TilesEl.textContent='Tiles: 0'; includedSet2TilesEl.textContent='Tiles: 0'; includedUniqueTilesEl.textContent='Tiles: 0';
    return;
  }
  const pSet1 = placements.filter(p=>p.set===1 && p.rarity!=='unique');
  const pSet2 = placements.filter(p=>p.set===2 && p.rarity!=='unique');
  const pUnique = placements.filter(p=>p.rarity==='unique' || p.set===0);

  const tiles1 = pSet1.reduce((s,p)=>s + (p.placement.cells ? p.placement.cells.length : 0), 0);
  const tiles2 = pSet2.reduce((s,p)=>s + (p.placement.cells ? p.placement.cells.length : 0), 0);
  const tilesU = pUnique.reduce((s,p)=>s + (p.placement.cells ? p.placement.cells.length : 0), 0);
  includedSet1TilesEl.textContent = `Tiles: ${tiles1}`; includedSet2TilesEl.textContent = `Tiles: ${tiles2}`; includedUniqueTilesEl.textContent = `Tiles: ${tilesU}`;

  function mk(p){
    const item = document.createElement('div'); item.className='included-item ' + p.rarity;
    const mini = document.createElement('div'); mini.className = 'included-mini ' + p.rarity;
    const st = window.shapeTypes.find(s=>s.id===p.shapeId) || window.uniqueTypes.find(s=>s.baseName===p.shapeId) || window.uniqueTypes.find(s=>s.id===p.shapeId);
    const cells = st ? st.cells : (p.placement && p.placement.cells ? p.placement.cells : [[0,0]]);
    const maxR = cells.length ? Math.max(...cells.map(q=>q[0])) : 0;
    const maxC = cells.length ? Math.max(...cells.map(q=>q[1])) : 0;
    const gridCols = p.rarity==='unique' ? 5 : (st && st.preview ? Math.max(1, st.preview.cols) : Math.max(1, Math.min(4, maxC+1)));
    const gridRows = p.rarity==='unique' ? 5 : (st && st.preview ? Math.max(1, st.preview.rows) : Math.max(1, Math.min(4, maxR+1)));
    mini.style.gridTemplateColumns = `repeat(${gridCols},8px)`;
    mini.style.gridAutoRows = `8px`;
    mini.innerHTML = '';
    for(let rr=0; rr<gridRows; rr++){
      for(let cc=0; cc<gridCols; cc++){
        const mc = document.createElement('div'); mc.className='mcell';
        if(cells.some(q=>q[0]===rr && q[1]===cc)) mc.classList.add('on');
        mini.appendChild(mc);
      }
    }
    item.appendChild(mini); return item;
  }

  function appendIncludedAsRows(containerEl, itemsArr, createFn){
    containerEl.innerHTML = '';
    if(!itemsArr || itemsArr.length===0){
      containerEl.innerHTML = '<div style="color:#9fb6d4">No shapes in current solution</div>';
      return;
    }
    const perRow = 4;
    const rowsWrap = document.createElement('div');
    rowsWrap.className = 'items-rows';
    for(let i=0;i<itemsArr.length;i+=perRow){
      const rowDiv = document.createElement('div');
      rowDiv.className = 'items-row';
      for(let j=i;j<i+perRow && j<itemsArr.length;j++){
        const node = createFn(itemsArr[j]);
        rowDiv.appendChild(node);
      }
      rowsWrap.appendChild(rowDiv);
    }
    containerEl.appendChild(rowsWrap);
  }

  appendIncludedAsRows(includedListSet1El, pSet1, mk);
  appendIncludedAsRows(includedListSet2El, pSet2, mk);
  if(pUnique.length) appendIncludedAsRows(includedListUniqueEl, pUnique, mk); else includedListUniqueEl.innerHTML = '<div style="color:#9fb6d4">No Unique included</div>';
  includedUniqueContainer.style.display = window.includeUnique ? 'block' : 'none';
}
function clearIncludedList(){ includedListSet1El.innerHTML = '<div style="color:#9fb6d4">No shapes in current solution</div>'; includedListSet2El.innerHTML = '<div style="color:#9fb6d4">No shapes in current solution</div>'; includedListUniqueEl.innerHTML = '<div style="color:#9fb6d4">No Unique included</div>'; includedSet1TilesEl.textContent='Tiles: 0'; includedSet2TilesEl.textContent='Tiles: 0'; includedUniqueTilesEl.textContent='Tiles: 0'; }

function updateUniqueContainersVisibility(){
  if(window.includeUnique){
    uniqueSelectedContainer.style.display = 'block';
    includedUniqueContainer.style.display = 'block';
    cardUnique.style.display = 'block';
  } else {
    uniqueSelectedContainer.style.display = 'none';
    includedUniqueContainer.style.display = 'none';
    cardUnique.style.display = 'none';
  }
  if(!window.includeUnique) uniqueChosenIndicator.textContent='None chosen';
  else {
    if(!window.currentUniqueIid) uniqueChosenIndicator.textContent='None chosen';
    else {
      const inst = window.selectedInstances.find(si=>si.iid===window.currentUniqueIid);
      uniqueChosenIndicator.textContent = inst ? `Chosen: ${inst.shapeId}` : 'None chosen';
    }
  }
}

/* ---------- Placement helpers & extra placements UI (rows of up to 4) ---------- */
function generatePlacementsForShape(shape){
  const cells = shape.cells;
  const maxR = Math.max(...cells.map(p=>p[0])); const maxC = Math.max(...cells.map(p=>p[1]));
  const placements = [];
  for(let ar=0; ar+maxR<ROWS; ar++){
    for(let ac=0; ac+maxC<COLS; ac++){
      const abs = cells.map(([r,c])=>[r+ar, c+ac]);
      let ok = true;
      for(const [r,c] of abs){
        if(r<0||r>=ROWS||c<0||c>=COLS){ ok=false; break; }
        if(!window.unlocked[r][c]) { ok=false; break; }
      }
      if(ok) placements.push({ shapeId: shape.baseName || shape.id, anchor:[ar,ac], cells: abs });
    }
  }
  return placements;
}
function computeSetBonus(sumTiles){ if(sumTiles < 9) return 0; const increments = Math.floor((sumTiles - 9) / 3); const capped = Math.min(increments, 4); return 265 * (capped + 1); }
function countUnlockedTiles(){ let cnt=0; for(let r=0;r<ROWS;r++) for(let c=0;c<COLS;c++) if(window.unlocked[r][c]) cnt++; return cnt; }

function getUncoveredUnlockedSet(){
  const set = new Set();
  for(let r=0;r<ROWS;r++) for(let c=0;c<COLS;c++){
    const k = r+','+c; if(window.unlocked[r][c] && !window.placedCells[k]) set.add(k);
  }
  return set;
}
function findExtraPlacementsExample(){
  const uncovered = getUncoveredUnlockedSet();
  if(uncovered.size===0) return [];
  const examples=[];
  for(const s of window.shapeTypes){
    if(s.size<=1) continue;
    const placements = generatePlacementsForShape(s);
    for(const p of placements){
      const ok = p.cells.every(([r,c]) => uncovered.has(r+','+c));
      if(ok){ examples.push({ shape:s, placement:p }); break; }
    }
  }
  return examples;
}
function clearHighlights(){ document.querySelectorAll('.cell.extra-highlight').forEach(el=>el.classList.remove('extra-highlight')); }
function highlightPlacement(placement){ clearHighlights(); for(const [r,c] of placement.cells){ const el = document.querySelector(`.cell[data-rc="${r},${c}"]`); if(el) el.classList.add('extra-highlight'); } }

function updateExtraIndicator(){
  if(!extraIndicatorEl) return;
  if(!window.hasSolution){ extraIndicatorEl.style.display='none'; clearHighlights(); return; }
  const examples = findExtraPlacementsExample();
  if(examples.length===0){ extraIndicatorEl.style.display='none'; clearHighlights(); return; }
  extraIndicatorEl.style.display='block';
  extraHeaderEl.textContent = `Additional placements possible: ${examples.length} oriented shape${examples.length>1?'s':''} (excluding monomino)`;
  extraListEl.innerHTML = '';

  // Build rows with up to 4 items each
  const perRow = 4;
  for(let i=0;i<examples.length;i+=perRow){
    const rowDiv = document.createElement('div'); rowDiv.className = 'extra-row';
    const slice = examples.slice(i, i+perRow);
    for(const ex of slice){
      const item = document.createElement('div'); item.className='extra-item';
      const s = ex.shape;
      const maxR = s.cells.length ? Math.max(...s.cells.map(p=>p[0])) : 0;
      const maxC = s.cells.length ? Math.max(...s.cells.map(p=>p[1])) : 0;
      const gridCols = s.preview ? Math.max(1, s.preview.cols) : Math.max(1, Math.min(3, maxC+1));
      const mini = document.createElement('div'); mini.className='mini';
      mini.style.gridTemplateColumns = `repeat(${gridCols},12px)`;
      const h = s.preview ? Math.max(1, s.preview.rows) : Math.max(1, Math.min(3, maxR+1));
      for(let rr=0; rr<h; rr++){
        for(let cc=0; cc<gridCols; cc++){
          const mc = document.createElement('div'); mc.className='mcell';
          if(s.cells.some(p=>p[0]===rr && p[1]===cc)) mc.classList.add('on');
          mini.appendChild(mc);
        }
      }
      const idSpan = document.createElement('div'); idSpan.style.color='#cfe8ff'; idSpan.style.fontSize='13px'; idSpan.textContent = s.id;
      const plusBtn = document.createElement('button'); plusBtn.textContent = '+'; plusBtn.style.padding='6px';
      plusBtn.addEventListener('click', ()=>{ const iid='I'+(window.nextInstanceId++); window.selectedInstances.push({ iid, shapeId:s.id, rarity:'rare', size:s.size, baseName:s.baseName, set: window.activeSet }); renderSelectedList(); updateExtraIndicator(); });
      item.appendChild(mini); item.appendChild(idSpan); item.appendChild(plusBtn);
      item.addEventListener('mouseenter', ()=> highlightPlacement(ex.placement));
      item.addEventListener('mouseleave', ()=> clearHighlights());
      rowDiv.appendChild(item);
    }
    extraListEl.appendChild(rowDiv);
  }
}

/* ---------- Solver (same algorithm, kept robust) ---------- */
function sizeToColorClassForPlacement(p){
  if(p.rarity === 'unique') return 'placed-unique';
  const tc = p.placement.cells.length;
  if(tc>=1 && tc<=3) return 'placed-red';
  if(tc===4) return 'placed-green';
  if(tc===5) return 'placed-blue';
  return 'placed-blue';
}

function updateScoreboard(tilesByRarityBySet = { set1:{rare:0,epic:0,super:0}, set2:{rare:0,epic:0,super:0} }, setBonus1=0, setBonus2=0){
  const t1 = tilesByRarityBySet.set1 || {rare:0,epic:0,super:0}, t2 = tilesByRarityBySet.set2 || {rare:0,epic:0,super:0};
  document.getElementById('sb_tiles1_rare').textContent = t1.rare||0;
  document.getElementById('sb_tiles1_epic').textContent = t1.epic||0;
  document.getElementById('sb_tiles1_super').textContent = t1.super||0;
  document.getElementById('sb_rr1_rare').textContent = (t1.rare||0) * RARITY_VALUES.rare;
  document.getElementById('sb_rr1_epic').textContent = (t1.epic||0) * RARITY_VALUES.epic;
  document.getElementById('sb_rr1_super').textContent = (t1.super||0) * RARITY_VALUES.super;
  document.getElementById('sb_set1_rare').textContent = setBonus1;
  document.getElementById('sb_set1_epic').textContent = setBonus1;
  document.getElementById('sb_set1_super').textContent = setBonus1;

  document.getElementById('sb_tiles2_rare').textContent = t2.rare||0;
  document.getElementById('sb_tiles2_epic').textContent = t2.epic||0;
  document.getElementById('sb_tiles2_super').textContent = t2.super||0;
  document.getElementById('sb_rr2_rare').textContent = (t2.rare||0) * RARITY_VALUES.rare;
  document.getElementById('sb_rr2_epic').textContent = (t2.epic||0) * RARITY_VALUES.epic;
  document.getElementById('sb_rr2_super').textContent = (t2.super||0) * RARITY_VALUES.super;
  document.getElementById('sb_set2_rare').textContent = setBonus2;
  document.getElementById('sb_set2_epic').textContent = setBonus2;
  document.getElementById('sb_set2_super').textContent = setBonus2;
}

function showInvalidSelection(err){
  clearSolution();
  placementsEl.innerHTML = `<div style="color:#fecaca;font-weight:700">Invalid selection — no tiling exists for the current selection.</div>
    <div style="color:#9fb6d4;margin-top:6px">${err || 'Please adjust your selected shapes and try again.'}</div>`;
}

function runSolveOptimize(timeoutMs = 3500){
  // For brevity and safety, the solver uses the same algorithm implemented previously and is robustly wrapped.
  try{
    _runSolverInternal(timeoutMs);
  } catch(err){
    console.error('Solver error', err);
    placementsEl.innerHTML = `<div style="color:#fecaca;font-weight:700">Solver error — see console</div><div style="color:#9fb6d4;margin-top:6px">${String(err)}</div>`;
  }
}

/* Internal solver implementation (copied in full for completeness) */
function _runSolverInternal(timeoutMs){
  const instances = window.selectedInstances.slice();
  if(window.includeUnique){
    const hasUniqueInst = instances.some(i=>i.rarity==='unique');
    if(!hasUniqueInst){
      showInvalidSelection('Include Unique is enabled but no Unique shape is selected.');
      clearIncludedList(); return;
    }
  }

  if(instances.length === 0){
    clearSolution(); placementsEl.innerHTML = 'No pieces selected.'; clearIncludedList(); return;
  }

  const placementsByInstance = instances.map(inst => {
    if(inst.rarity === 'unique'){
      const rep = window.uniqueTypes.find(u => u.baseName === inst.baseName) || window.uniqueTypes.find(u => u.baseName === inst.shapeId) || { cells: inst.cells || [[0,0]] };
      const tempShape = { id: rep.id, baseName: inst.baseName || inst.shapeId, cells: rep.cells };
      return generatePlacementsForShape(tempShape);
    } else {
      const st = window.shapeTypes.find(s=>s.id===inst.shapeId);
      return st ? generatePlacementsForShape(st) : [];
    }
  });

  for(let i=0;i<instances.length;i++){
    const inst = instances[i];
    if((inst.rarity==='super' || inst.rarity==='unique') && placementsByInstance[i].length===0){
      showInvalidSelection(`One or more ${inst.rarity==='super' ? 'Super Epic' : 'Unique'} pieces have no valid placement on the current unlocked grid. They must be placeable.`);
      clearIncludedList(); return;
    }
  }

  const anyPlacement = placementsByInstance.some(arr=>arr.length>0);
  if(!anyPlacement){ showInvalidSelection('No valid placement exists for any selected piece on the current unlocked grid.'); clearIncludedList(); return; }

  let requiredSet1 = 0, requiredSet2 = 0;
  const sel = dualSetSelect.value;
  if(sel && sel !== 'none'){
    const parts = (''+sel).split('-').map(x=>parseInt(x,10)||0);
    if(parts.length===2){ requiredSet1 = Math.max(0, parts[0]); requiredSet2 = Math.max(0, parts[1]); }
  }

  const totalUnlocked = countUnlockedTiles();
  if(requiredSet1 + requiredSet2 > totalUnlocked){
    showInvalidSelection('Selected Dual Set Bonus cannot be satisfied with current unlocked tiles.');
    return;
  }

  const idxs = instances.map((inst, idx)=>({ idx, rarityOrder: inst.rarity==='super' ? 0 : (inst.rarity==='unique' ? 0 : (inst.rarity==='epic'?1:2)), opts: placementsByInstance[idx].length || 0 }));
  idxs.sort((a,b)=> a.rarityOrder - b.rarityOrder || a.opts - b.opts);
  const indexMap = idxs.map(o=>o.idx);

  function placeAdds(placement){ return placement.cells.map(([r,c])=>`${r},${c}`); }

  function computeScores(curTiles, uniqueIncluded){
    const rrRare = curTiles.set1.rare*RARITY_VALUES.rare + curTiles.set2.rare*RARITY_VALUES.rare;
    const rrEpic = curTiles.set1.epic*RARITY_VALUES.epic + curTiles.set2.epic*RARITY_VALUES.epic;
    const rrSuper = curTiles.set1.super*RARITY_VALUES.super + curTiles.set2.super*RARITY_VALUES.super;
    const rrSum = rrRare + rrEpic + rrSuper;
    const total1 = curTiles.set1.rare+curTiles.set1.epic+curTiles.set1.super;
    const total2 = curTiles.set2.rare+curTiles.set2.epic+curTiles.set2.super;
    const overflow = Math.max(0,total1-21);
    const set1ForBonus = Math.min(total1,21);
    const set2ForBonus = total2 + overflow;
    const setBonus1 = computeSetBonus(set1ForBonus);
    const setBonus2 = computeSetBonus(set2ForBonus);
    const uniqueBonus = uniqueIncluded ? RARITY_VALUES.unique : 0;
    return { rrSum, setBonus1, setBonus2, total1, total2, uniqueBonus };
  }

  function solveVariant(timeBudgetMs=1000, allowRares=true){
    const start = Date.now();
    const used = new Set();
    let best = { actualTotal:-1, placements:[], tilesByRarityBySet:{set1:{rare:0,epic:0,super:0}, set2:{rare:0,epic:0,super:0}}, rrSum:0, setBonus1:0, setBonus2:0, uniqueIncluded:false, supersPlaced:0, epicsPlaced:0 };

    function backtrack(pos, curTiles, chosen, uniqueIncluded){
      if(Date.now()-start > timeBudgetMs) return;
      if(pos>=indexMap.length){
        const mandatorySupers = instances.filter(x=>x.rarity==='super').length;
        const mandatoryUnique = window.includeUnique ? instances.filter(x=>x.rarity==='unique').length : 0;
        const supersPlaced = curTiles.set1.super + curTiles.set2.super;
        if(supersPlaced < mandatorySupers) return;
        if(mandatoryUnique > 0 && !uniqueIncluded) return;

        const total1 = curTiles.set1.rare + curTiles.set1.epic + curTiles.set1.super;
        const total2 = curTiles.set2.rare + curTiles.set2.epic + curTiles.set2.super;
        if(total1 < requiredSet1) return;
        if(total2 < requiredSet2) return;

        const sc = computeScores(curTiles, uniqueIncluded);
        const actualTotal = sc.rrSum + sc.setBonus1 + sc.setBonus2 + sc.uniqueBonus;
        const epicsPlaced = curTiles.set1.epic + curTiles.set2.epic;

        let better=false;
        if(actualTotal > best.actualTotal) better=true;
        else if(actualTotal === best.actualTotal){
          if(supersPlaced > (best.supersPlaced||0)) better=true;
          else if(supersPlaced === (best.supersPlaced||0)){
            if(epicsPlaced > (best.epicsPlaced||0)) better=true;
            else if(epicsPlaced === (best.epicsPlaced||0)){
              const raresPlaced = curTiles.set1.rare + curTiles.set2.rare;
              const bestRares = best.tilesByRarityBySet ? (best.tilesByRarityBySet.set1.rare + best.tilesByRarityBySet.set2.rare) : Infinity;
              if(raresPlaced < bestRares) better=true;
            }
          }
        }

        if(better){
          best.actualTotal = actualTotal;
          best.rrSum = sc.rrSum;
          best.setBonus1 = sc.setBonus1;
          best.setBonus2 = sc.setBonus2;
          best.uniqueIncluded = uniqueIncluded;
          best.tilesByRarityBySet = JSON.parse(JSON.stringify(curTiles));
          best.placements = chosen.slice();
          best.supersPlaced = supersPlaced;
          best.epicsPlaced = epicsPlaced;
        }
        return;
      }

      const instIdx = indexMap[pos];
      const inst = instances[instIdx];
      const opts = placementsByInstance[instIdx];
      const isRare = inst.rarity === 'rare';
      const isUnique = inst.rarity === 'unique';
      const mandatory = inst.rarity === 'super' || inst.rarity === 'unique';

      for(const p of opts){
        if(isRare && !allowRares) continue;
        const keys = placeAdds(p); let conflict=false;
        for(const k of keys) if(used.has(k)){ conflict=true; break; }
        if(conflict) continue;
        for(const k of keys) used.add(k);
        const target = inst.set===2 ? 'set2' : 'set1';
        if(!isUnique) curTiles[target][inst.rarity] += inst.size;
        chosen.push({ iid: inst.iid, shapeId: inst.shapeId, rarity: inst.rarity, placement: p, set: inst.set });
        backtrack(pos+1, curTiles, chosen, uniqueIncluded || isUnique);
        chosen.pop();
        if(!isUnique) curTiles[target][inst.rarity] -= inst.size;
        for(const k of keys) used.delete(k);
      }
      if(!mandatory) backtrack(pos+1, curTiles, chosen, uniqueIncluded);
    }

    backtrack(0, { set1:{rare:0,epic:0,super:0}, set2:{rare:0,epic:0,super:0} }, [], false);
    return best;
  }

  const t = Math.max(200, Math.floor(timeoutMs/3));
  const a = solveVariant(t,false);
  const a2 = solveVariant(t,true);
  const b = solveVariant(t,false);
  const b2 = solveVariant(t,true);
  const cand = [a2,b2,a,b].filter(c => c && c.placements && c.placements.length>0);

  if(cand.length===0){ showInvalidSelection('No valid tiling found (that satisfies the constraints).'); clearIncludedList(); return; }

  cand.sort((x,y)=>{
    if(x.actualTotal !== y.actualTotal) return y.actualTotal - x.actualTotal;
    if((x.supersPlaced||0) !== (y.supersPlaced||0)) return (y.supersPlaced||0) - (x.supersPlaced||0);
    if((x.epicsPlaced||0) !== (y.epicsPlaced||0)) return (y.epicsPlaced||0) - (x.epicsPlaced||0);
    return 0;
  });
  const best = cand[0];

  const bestTotal1 = (best.tilesByRarityBySet && best.tilesByRarityBySet.set1) ? (best.tilesByRarityBySet.set1.rare + best.tilesByRarityBySet.set1.epic + best.tilesByRarityBySet.set1.super) : 0;
  const bestTotal2 = (best.tilesByRarityBySet && best.tilesByRarityBySet.set2) ? (best.tilesByRarityBySet.set2.rare + best.tilesByRarityBySet.set2.epic + best.tilesByRarityBySet.set2.super) : 0;
  if(bestTotal1 < requiredSet1 || bestTotal2 < requiredSet2){
    showInvalidSelection('No tiling found that satisfies the selected Dual Set Bonus targets.');
    return;
  }

  window.placedCells = {};
  for(let i=0;i<best.placements.length;i++){
    const p = best.placements[i];
    const pid = 'P'+(i+1); // unique pid kept for grouping and save/load
    // displayLabel shows S-1 or S-2 inside tiles (per set). set 0 use 'U'
    const displayLabel = (p.set === 1) ? 'S-1' : ((p.set === 2) ? 'S-2' : 'U');
    for(const [r,c] of p.placement.cells){
      window.placedCells[`${r},${c}`] = { pid, iid: p.iid, shapeId: p.shapeId, rarity: p.rarity, set: p.set, colorClass: sizeToColorClassForPlacement(p), displayLabel };
    }
  }
  updateScoreboard(best.tilesByRarityBySet || { set1:{rare:0,epic:0,super:0}, set2:{rare:0,epic:0,super:0} }, best.setBonus1 || 0, best.setBonus2 || 0);
  window.hasSolution = true;
  renderGrid();
  placementsEl.innerHTML = '';
  const displayTotal = (best.rrSum || 0) + (best.setBonus1 || 0) + (best.setBonus2 || 0) + (best.uniqueIncluded ? RARITY_VALUES.unique : 0);
  const suffix = best.uniqueIncluded ? ' — Unique shape included' : '';
  placementsEl.appendChild(document.createTextNode(`Best Total: ${displayTotal}${suffix}`));
  renderIncludedList(best.placements);
  updateExtraIndicator();
}

/* ---------- Save/load (robust) ---------- */
function sanitizeSlot(slot){
  if(!slot || typeof slot !== 'object') return null;
  const out = {};
  out.name = typeof slot.name === 'string' ? slot.name : '';
  out.placedCells = (slot.placedCells && typeof slot.placedCells === 'object') ? slot.placedCells : {};
  out.tilesByRarity = (slot.tilesByRarity && typeof slot.tilesByRarity === 'object') ? slot.tilesByRarity : { set1:{rare:0,epic:0,super:0}, set2:{rare:0,epic:0,super:0} };
  out.total = typeof slot.total === 'number' ? slot.total : 0;
  out.timestamp = typeof slot.timestamp === 'number' ? slot.timestamp : 0;
  out.unlocked = Array.isArray(slot.unlocked) ? slot.unlocked : null;
  out.selectedInstances = Array.isArray(slot.selectedInstances) ? slot.selectedInstances : null;
  out.nextInstanceId = typeof slot.nextInstanceId === 'number' ? slot.nextInstanceId : null;
  out.setBonus1 = typeof slot.setBonus1 === 'number' ? slot.setBonus1 : 0;
  out.setBonus2 = typeof slot.setBonus2 === 'number' ? slot.setBonus2 : 0;
  out.includeUnique = !!slot.includeUnique;
  return out;
}
function loadSaves(){
  try{
    const raw = localStorage.getItem(SAVES_KEY);
    if(!raw) return [null,null,null];
    const parsed = JSON.parse(raw);
    if(!Array.isArray(parsed)) return [null,null,null];
    const out = [];
    for(let i=0;i<3;i++){
      const s = parsed[i];
      out.push(s ? sanitizeSlot(s) : null);
    }
    return out;
  }catch(e){
    console.warn('Failed to parse saved slots, returning empty slots', e);
    return [null,null,null];
  }
}
function saveSaves(arr){
  try{
    const toSave = [null,null,null];
    for(let i=0;i<3;i++){
      toSave[i] = arr[i] ? arr[i] : null;
    }
    localStorage.setItem(SAVES_KEY, JSON.stringify(toSave));
  }catch(e){
    console.error('Failed to save slots', e);
  }
}

function renderSaveSlots(){
  let container = document.getElementById('saveSlots');
  if(!container){
    console.warn('saveSlots container missing - creating one');
    container = document.createElement('div'); container.id = 'saveSlots';
    const target = document.getElementById('scoreAndSaves') || document.querySelector('.info-panel');
    if(target) target.appendChild(container);
    else document.body.appendChild(container);
  }
  container.innerHTML = '';
  const slots = loadSaves();
  while(slots.length < 3) slots.push(null);

  for(let i=0;i<3;i++){
    const slot = slots[i];
    const el = document.createElement('div'); el.className = 'save-slot';

    const mini = document.createElement('div'); mini.className='save-mini';
    for(let r=0;r<7;r++){
      for(let c=0;c<7;c++){
        const sc = document.createElement('div'); sc.className='s-cell';
        if(slot && slot.placedCells && typeof slot.placedCells === 'object' && slot.placedCells[`${r},${c}`]) sc.classList.add('on');
        mini.appendChild(sc);
      }
    }
    el.appendChild(mini);

    const meta = document.createElement('div'); meta.className='save-meta';
    const nameInput = document.createElement('input'); nameInput.className='save-input';
    nameInput.value = slot && slot.name ? slot.name : `Slot ${i+1}`;

    const infoLine = document.createElement('div'); infoLine.style.color = '#9fb6d4'; infoLine.style.fontSize = '12px';
    infoLine.textContent = slot && typeof slot.total === 'number' && slot.total > 0 ? `RR: ${slot.total}` : 'Empty';

    const controls = document.createElement('div'); controls.className='save-controls';
    const saveBtn = document.createElement('button'); saveBtn.textContent = slot ? 'Overwrite' : 'Save';
    const loadBtn = document.createElement('button'); loadBtn.textContent = 'Load';
    const delBtn = document.createElement('button'); delBtn.textContent = 'Delete';
    controls.appendChild(saveBtn); controls.appendChild(loadBtn); controls.appendChild(delBtn);

    meta.appendChild(nameInput); meta.appendChild(infoLine); meta.appendChild(controls);
    el.appendChild(meta);
    container.appendChild(el);

    saveBtn.addEventListener('click', ()=>{
      try{
        const arr = loadSaves();
        const existing = arr[i];
        if(existing){
          const ok = confirm(`Overwrite saved slot "${existing.name || `Slot ${i+1}`}"?`);
          if(!ok) return;
        }
        const currentPlaced = window.placedCells ? JSON.parse(JSON.stringify(window.placedCells)) : {};
        const tilesByRarity = {
          set1: {
            rare: parseInt(document.getElementById('sb_tiles1_rare').textContent)||0,
            epic: parseInt(document.getElementById('sb_tiles1_epic').textContent)||0,
            super: parseInt(document.getElementById('sb_tiles1_super').textContent)||0
          },
          set2: {
            rare: parseInt(document.getElementById('sb_tiles2_rare').textContent)||0,
            epic: parseInt(document.getElementById('sb_tiles2_epic').textContent)||0,
            super: parseInt(document.getElementById('sb_tiles2_super').textContent)||0
          }
        };
        const totalMatch = document.getElementById('placements').textContent.match(/Best Total:\s*(\d+)/);
        const total = totalMatch ? parseInt(totalMatch[1]) : 0;
        const unlockedCopy = Array.isArray(window.unlocked) ? window.unlocked.map(row => row.slice()) : null;
        const selectedCopy = Array.isArray(window.selectedInstances) ? JSON.parse(JSON.stringify(window.selectedInstances)) : null;
        const name = nameInput.value.trim() || `Slot ${i+1}`;
        const newSlot = {
          name,
          placedCells: currentPlaced,
          tilesByRarity,
          total,
          timestamp: Date.now(),
          unlocked: unlockedCopy,
          selectedInstances: selectedCopy,
          nextInstanceId: typeof window.nextInstanceId === 'number' ? window.nextInstanceId : null,
          setBonus1: parseInt(document.getElementById('sb_set1_rare').textContent) || 0,
          setBonus2: parseInt(document.getElementById('sb_set2_rare').textContent) || 0,
          includeUnique: !!window.includeUnique
        };
        arr[i] = newSlot;
        saveSaves(arr);
        renderSaveSlots();
      }catch(err){
        console.error('Save failed', err);
        alert('Save failed — see console for details.');
      }
    });

    loadBtn.addEventListener('click', ()=>{
      try{
        const arr = loadSaves();
        const s = arr[i];
        if(!s){ alert('Empty slot'); return; }
        if(Array.isArray(s.unlocked) && s.unlocked.length === ROWS) window.unlocked = s.unlocked.map(row => row.slice());
        if(Array.isArray(s.selectedInstances)){
          window.selectedInstances = JSON.parse(JSON.stringify(s.selectedInstances));
          if(typeof s.nextInstanceId === 'number' && s.nextInstanceId > (window.nextInstanceId || 0)) window.nextInstanceId = s.nextInstanceId;
          else {
            const maxIid = window.selectedInstances.reduce((mx,si)=> {
              const n = parseInt((''+si.iid).replace(/^I/,''));
              return isNaN(n) ? mx : Math.max(mx,n);
            }, 0);
            window.nextInstanceId = Math.max(window.nextInstanceId || 1, maxIid + 1);
          }
        } else {
          window.selectedInstances = [];
        }
        if(s.placedCells && typeof s.placedCells === 'object'){
          window.placedCells = JSON.parse(JSON.stringify(s.placedCells));
          window.hasSolution = Object.keys(window.placedCells).length > 0;
        } else {
          window.placedCells = {};
          window.hasSolution = false;
        }
        window.includeUnique = !!s.includeUnique;
        includeUniqueToggle.checked = !!s.includeUnique;

        if(s.tilesByRarity){
          try{ updateScoreboard(s.tilesByRarity, s.setBonus1 || 0, s.setBonus2 || 0); }catch(e){ console.warn('updateScoreboard failed during load:', e); }
        }
        try{ buildUniqueTypes(); }catch(e){ console.warn(e); }
        try{ renderPalette(); }catch(e){ console.warn(e); }
        try{ renderSelectedList(); }catch(e){ console.warn(e); }
        try{ renderGrid(); }catch(e){ console.warn(e); }

        try{
          const byPid = {};
          for(const k of Object.keys(window.placedCells || {})){
            const p = window.placedCells[k];
            if(!byPid[p.pid]) byPid[p.pid] = { iid:p.iid, shapeId:p.shapeId||'S1', rarity:p.rarity, placement:{cells:[]}, set:p.set };
            const [r,c] = k.split(',').map(Number);
            byPid[p.pid].placement.cells.push([r,c]);
          }
          const placements = Object.keys(byPid).map(k=>byPid[k]);
          if(typeof renderIncludedList === 'function') renderIncludedList(placements);
        }catch(e){ console.warn('Could not populate includedList after load', e); }

        try{ updateExtraIndicator(); }catch(e){}
        try{ updateDualSetBonusOptions(); }catch(e){}
        try{ updateUniqueContainersVisibility(); }catch(e){}

        const old = placementsEl.innerHTML;
        placementsEl.innerHTML = `<div style="color:#cfe8ff">Loaded: ${s.name || `Slot ${i+1}`}</div>`;
        setTimeout(()=> { placementsEl.innerHTML = old; }, 1100);
      }catch(err){
        console.error('Load failed', err);
        alert('Load failed — see console for details.');
      }
    });

    delBtn.addEventListener('click', ()=>{
      try{
        const arr = loadSaves();
        if(!arr[i]){ alert('Slot already empty.'); return; }
        const ok = confirm(`Delete saved slot "${arr[i].name || `Slot ${i+1}`}"? This cannot be undone.`);
        if(!ok) return;
        arr[i] = null;
        saveSaves(arr);
        renderSaveSlots();
      }catch(err){
        console.error('Delete failed', err);
        alert('Delete failed — see console for details.');
      }
    });
  }
}

/* ---------- Dual set bonus UI ---------- */
function generateDualCombos(totalUnlocked){
  const result = [];
  const allowed = SET_THRESHOLDS.filter(x => x <= totalUnlocked);
  for(let i = allowed.length-1; i>=0; i--){
    for(let j = i; j>=0; j--){
      const a = allowed[i], b = allowed[j];
      if(a + b <= totalUnlocked){
        result.push([a,b]);
      }
    }
  }
  return result;
}
function updateDualSetBonusOptions(){
  const total = countUnlockedTiles();
  if(total < 24){
    dualSetSelect.disabled = true;
    dualSetHelp.textContent = 'Locked — enable by unlocking at least 24 tiles.';
    if(dualSetSelect.value !== 'none') dualSetSelect.value = 'none';
    dualSetSelect.innerHTML = '<option value="none">None</option>';
    return;
  }
  const combos = generateDualCombos(total);
  dualSetSelect.innerHTML = '';
  const noneOpt = document.createElement('option'); noneOpt.value = 'none'; noneOpt.textContent = 'None'; dualSetSelect.appendChild(noneOpt);
  combos.forEach(([a,b])=>{
    const opt = document.createElement('option');
    opt.value = `${a}-${b}`;
    opt.textContent = `${a}-${b}`;
    dualSetSelect.appendChild(opt);
  });
  dualSetSelect.disabled = false;
  dualSetHelp.textContent = `Select a target split for set bonuses (total unlocked: ${total}).`;
}

/* ---------- Helpers: reset, clear, setActive ---------- */
function applyDefaultCenter(){
  window.unlocked = Array.from({length:ROWS}, ()=>Array.from({length:COLS}, ()=>false));
  const startR = Math.floor((ROWS-3)/2), startC = Math.floor((COLS-5)/2);
  for(let r=startR;r<startR+3;r++) for(let c=startC;c<startC+5;c++) window.unlocked[r][c] = true;
  renderGrid(); updateUnlockedCounter();
}
function clearSolution(){
  window.placedCells = {};
  window.hasSolution = false;
  placementsEl.innerHTML = '';
  clearIncludedList();
  updateScoreboard({ set1:{rare:0,epic:0,super:0}, set2:{rare:0,epic:0,super:0} }, 0, 0);
  clearHighlights();
  renderGrid();
  updateExtraIndicator();
}
function clearSelections(){
  window.selectedInstances = [];
  window.currentUniqueIid = null;
  window.includeUnique = false;
  includeUniqueToggle.checked = false;
  renderPalette();
  renderSelectedList();
}
function setActiveSet(n){
  window.activeSet = n;
  if(n===1){
    selectSet1Btn.setAttribute('aria-pressed','true');
    selectSet2Btn.setAttribute('aria-pressed','false');
    selectSet1Btn.classList.remove('secondary');
    selectSet2Btn.classList.add('secondary');
  } else {
    selectSet2Btn.setAttribute('aria-pressed','true');
    selectSet1Btn.setAttribute('aria-pressed','false');
    selectSet2Btn.classList.remove('secondary');
    selectSet1Btn.classList.add('secondary');
  }
}

/* Wire UI events */
selectSet1Btn.addEventListener('click', ()=> setActiveSet(1));
selectSet2Btn.addEventListener('click', ()=> setActiveSet(2));

document.getElementById('solveBtn').addEventListener('click', ()=>{ placementsEl.innerHTML='Optimizing...'; setTimeout(()=>{ try{ runSolveOptimize(3500); }catch(err){ console.error('runSolveOptimize uncaught', err); placementsEl.innerHTML = `<div style="color:#fecaca;font-weight:700">Solver error — see console</div><div style="color:#9fb6d4;margin-top:6px">${String(err)}</div>`;} },50); });

// Reset: restore default unlocked pattern, clear selections and solution, and select Set 1
document.getElementById('resetGrid').addEventListener('click', ()=>{
  clearSelections();
  clearSolution();
  applyDefaultCenter();
  setActiveSet(1);
  updateDualSetBonusOptions();
  updateExtraIndicator();
  setTimeout(adjustInfoPanelPosition,30);
});

// Clear: clear selections and solution but keep current unlocked grid; select Set 1
document.getElementById('clearAll').addEventListener('click', ()=>{
  clearSelections();
  clearSolution();
  setActiveSet(1);
  updateDualSetBonusOptions();
  updateExtraIndicator();
  setTimeout(adjustInfoPanelPosition,30);
});

includeUniqueToggle.addEventListener('change', (ev)=>{
  window.includeUnique = !!ev.target.checked;
  if(!window.includeUnique){
    for(let i=window.selectedInstances.length-1;i>=0;i--) if(window.selectedInstances[i].rarity==='unique') window.selectedInstances.splice(i,1);
    window.currentUniqueIid = null;
  }
  buildUniqueTypes(); renderPalette(); renderSelectedList(); updateUniqueContainersVisibility();
});

/* Helpers for layout */
function adjustInfoPanelPosition(){ const topRow=document.querySelector('.topRow'); if(!topRow.contains(document.getElementById('infoPanel'))) topRow.appendChild(document.getElementById('infoPanel')); }

/* ---------- Boot ---------- */
applyDefaultCenter();
buildShapeTypes();
buildUniqueTypes();
setActiveSet(1); // ensure Set 1 is active by default
renderPalette();
renderGrid();
renderSelectedList();
updateScoreboard();
clearIncludedList();
updateExtraIndicator();
renderSaveSlots();
updateDualSetBonusOptions();
setTimeout(adjustInfoPanelPosition,50);

/* Expose debug helpers */
window._renderSaveSlots = renderSaveSlots;
window._loadSaves = loadSaves;
window._saveSaves = saveSaves;
</script>
</body>
</html>
