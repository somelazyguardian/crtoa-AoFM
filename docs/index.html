<!doctype html>
<html>
<head>
<meta charset="utf-8"/>
<title>CR:TOA Rift Resistance Optimizer</title>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<style>
  :root{
    --bg:#0f1724;
    --muted:#9fb6d4;
    --accent:#cfe8ff;
    --card:#0b1220;
    --card-border: rgba(255,255,255,0.04);
    --rare:#2679F8;
    --epic:#D85FFF;
    --super:#F84747;
    --highlight: rgba(255,193,7,0.85);
  }
  html,body{height:100%;width:100%;margin:0;padding:10px;background:var(--bg);color:var(--accent);font-family:system-ui, -apple-system, "Segoe UI", Roboto, Arial;box-sizing:border-box;}
  *{box-sizing:inherit}
  h1{margin:0 0 10px 0;font-size:16px}
  .container{display:flex;flex-direction:column;gap:14px}
  .topRow{display:flex;gap:14px;align-items:flex-start;flex-wrap:nowrap}
  .grid-wrap{min-width:300px}
  .board{background:linear-gradient(180deg,#111827,#0b1220);padding:10px;border-radius:8px;box-shadow:0 6px 18px rgba(0,0,0,0.6);min-width:300px;max-width:360px}
  .info-panel{background:linear-gradient(180deg,#07101a,#071421);padding:10px;border-radius:8px;border:1px solid rgba(255,255,255,0.03);display:flex;gap:10px;align-items:flex-start}
  .controls-top{display:flex;justify-content:space-between;align-items:center;margin-bottom:8px;gap:8px}
  .controls-left{display:flex;gap:8px;align-items:center}
  button{background:#2563eb;color:white;border:none;padding:7px 10px;border-radius:8px;cursor:pointer;font-size:13px}
  button.secondary{background:#1f2937;color:var(--accent);border:1px solid rgba(255,255,255,0.03);padding:6px 8px}
  .grid{display:grid;grid-template-columns:repeat(7,46px);grid-auto-rows:46px;gap:6px;margin-bottom:8px;justify-content:center}
  .cell{width:46px;height:46px;border-radius:8px;display:flex;align-items:center;justify-content:center;cursor:pointer;user-select:none;font-size:13px;font-weight:700;position:relative;overflow:hidden}
  .cell.locked{background:#233045;border:1px solid #0f1724;color:#6b7280}
  .cell.unlocked{background:#dbeafe;color:#022c3a;box-shadow:inset 0 -3px 6px rgba(0,0,0,0.06)}
  .cell.placed{color:#022c3a}
  .placed-red{background:linear-gradient(135deg,#fca5a5,#fecaca); color:#3a0a0a}
  .placed-green{background:linear-gradient(135deg,#86efac,#bbf7d0); color:#03210a}
  .placed-blue{background:linear-gradient(135deg,#93c5fd,#bfdbfe); color:#021029}
  .outline-rare { box-shadow: inset 0 0 0 3px var(--rare); }
  .outline-epic { box-shadow: inset 0 0 0 3px var(--epic); }
  .outline-super { box-shadow: inset 0 0 0 3px var(--super); }
  .extra-highlight { outline: 3px solid var(--highlight); outline-offset: -3px; }

  .palette-wrap{display:flex;gap:10px;align-items:flex-start;flex:1;min-width:360px;max-width:920px;flex-wrap:wrap}
  .category-card{background:linear-gradient(180deg,var(--card),#061018);border-radius:8px;padding:8px;border:1px solid var(--card-border);flex:1;display:flex;flex-direction:column;min-width:130px;max-height:640px;overflow:hidden}
  .category-head{display:flex;align-items:center;gap:8px;margin-bottom:6px;font-weight:700;color:var(--accent);font-size:13px}
  .category-body{overflow:auto;padding-right:6px;flex:1}
  .dot{width:10px;height:10px;border-radius:50%;display:inline-block}
  .shape-row{display:flex;gap:8px;align-items:center;margin-bottom:6px;padding:4px 2px;border-radius:6px}
  .mini{display:grid;grid-template-columns:repeat(3,12px);grid-auto-rows:12px;gap:2px}
  .mini .mcell{width:12px;height:12px;background:rgba(255,255,255,0.04);border-radius:2px}
  .mini .mcell.on{background:linear-gradient(180deg,#bae6fd,#60a5fa)}
  .shape-id{width:36px;font-size:12px;color:var(--muted);text-align:left}
  .count{display:flex;align-items:center;gap:6px;margin-left:auto}
  .count input{width:40px;font-size:12px;padding:4px;border-radius:6px;border:1px solid #213244;background:#071021;color:var(--accent);text-align:center;height:28px}

  /* compact selected/included UI */
  .panel-column{display:flex;flex-direction:column;gap:8px;min-width:140px}
  .selected-area{padding:8px;border-radius:8px;background:linear-gradient(180deg,#07101a,#071421);border:1px solid rgba(255,255,255,0.03)}
  .selected-title{display:flex;align-items:center;gap:8px;margin-bottom:6px;color:var(--accent);font-weight:700}
  .selected-sets{display:flex;gap:8px}
  .selected-set{flex:1;padding:8px;border-radius:8px;background:rgba(255,255,255,0.02);min-height:64px;display:flex;flex-direction:column;gap:6px}
  .selected-list{display:flex;flex-direction:row;flex-wrap:wrap;gap:8px;align-items:center}
  .selected-item{display:flex;flex-direction:row;gap:6px;align-items:center;padding:4px;border-radius:6px;cursor:pointer;user-select:none;font-size:13px;flex:0 0 auto}
  .selected-item.rare { background: var(--rare); color: #021029; }
  .selected-item.epic { background: var(--epic); color: #fff; }
  .selected-item.super { background: var(--super); color: #fff; }

  .selected-mini{Width:28px;height:28px;display:grid;grid-template-columns:repeat(3,8px);grid-auto-rows:8px;gap:2px;border-radius:4px;overflow:hidden}
  .selected-mini .mcell{width:8px;height:8px;background:rgba(255,255,255,0.04);border-radius:1px}
  .selected-mini .mcell.on{background:rgba(255,255,255,0.85)}

  .included-area{padding:8px;border-radius:8px;background:linear-gradient(180deg,#06111a,#061216);border:1px solid rgba(255,255,255,0.02)}
  .included-sets{display:flex;gap:8px}
  .included-set{flex:1;padding:8px;border-radius:8px;background:rgba(255,255,255,0.02);min-height:64px;display:flex;flex-direction:column;gap:6px}
  .included-list{display:flex;flex-direction:row;flex-wrap:wrap;gap:8px;align-items:center}
  .included-item{display:flex;gap:8px;align-items:center;padding:4px;border-radius:6px;font-size:13px;flex:0 0 auto}
  .included-mini{width:28px;height:28px;display:grid;grid-template-columns:repeat(3,8px);grid-auto-rows:8px;gap:2px;border-radius:4px;overflow:hidden;align-items:center;justify-items:center}
  .included-mini.rare{background:linear-gradient(180deg,#cfe8ff18,var(--rare));}
  .included-mini.epic{background:linear-gradient(180deg,#f7d8ff18,var(--epic));}
  .included-mini.super{background:linear-gradient(180deg,#ffd8d818,var(--super));}
  .included-mini .mcell{width:8px;height:8px;background:rgba(255,255,255,0.12);border-radius:1px}
  .included-mini .mcell.on{background:rgba(255,255,255,0.95)}

  .scoreboard { width:100%; border-collapse:collapse; font-size:13px; color:var(--accent); margin-bottom:8px }
  .scoreboard th, .scoreboard td { border:1px solid rgba(255,255,255,0.04); padding:6px 8px; text-align:center; }
  .scoreboard .colheader { font-weight:700; }

  .saves-area{padding:8px;border-radius:8px;background:linear-gradient(180deg,#061018,#050d12);border:1px solid rgba(255,255,255,0.02);min-width:220px}
  .save-slot{display:flex;gap:8px;align-items:center;padding:6px;border-radius:6px;background:rgba(255,255,255,0.01)}
  .save-mini{width:84px;height:84px;background:#071422;border-radius:6px;display:grid;grid-template-columns:repeat(7,1fr);grid-auto-rows:1fr;gap:1px;padding:2px}
  .save-mini .s-cell{background:rgba(255,255,255,0.02);border-radius:2px}
  .save-mini .s-cell.on{background:linear-gradient(180deg,#bae6fd,#60a5fa)}
  .save-meta{flex:1;display:flex;flex-direction:column;gap:6px}
  .save-controls{display:flex;gap:6px}
  .save-input{width:100%;background:#071421;border:1px solid rgba(255,255,255,0.02);color:var(--accent);padding:4px;border-radius:6px}
  .extra-indicator { margin-top:8px; padding:8px; border-radius:6px; background: linear-gradient(180deg,#071421,#061219); border:1px solid rgba(255,255,255,0.03); color:#cfe8ff; font-size:13px; }
  .extra-list { display:flex; gap:8px; flex-wrap:wrap; margin-top:8px; }
  .extra-item { display:flex; gap:6px; align-items:center; padding:6px; border-radius:6px; background: rgba(255,255,255,0.02); }
  .placements{margin-top:8px;font-size:13px;color:var(--accent);max-height:180px;overflow:auto}

  @media (max-width:980px){
    .topRow{flex-direction:column}
    .info-panel{width:100%}
    .palette-wrap{width:100%;flex-direction:row;flex-wrap:wrap}
    .category-card{max-width:48%}
    .grid{grid-template-columns:repeat(7,calc((100% - 6*6px)/7));grid-auto-rows:calc((100% - 6*6px)/7)}
  }
</style>
</head>
<body>
<h1>CR:TOA Rift Resistance Optimizer</h1>

<div class="container">
  <div class="topRow">
    <div class="grid-wrap">
      <div class="board">
        <div class="controls-top">
          <div class="controls-left">
            <div style="color:#9fb6d4;font-size:12px">Click cells to toggle locked/unlocked</div>
            <div id="unlockedCounter" style="color:#9fb6d4;font-size:12px;margin-left:8px">Unlocked: 0</div>
          </div>
          <div style="display:flex;gap:8px;align-items:center">
            <div>
              <button id="solveBtn">Solve (maximize Total)</button>
              <button id="resetGrid" class="secondary">Reset</button>
              <button id="clearAll" class="secondary">Clear</button>
            </div>
            <div style="display:flex;flex-direction:column;gap:4px;margin-left:8px">
              <div style="color:#9fb6d4;font-size:12px;text-align:right">Active Set</div>
              <div style="display:flex;gap:6px">
                <button id="selectSet1" class="secondary" aria-pressed="true">Set 1</button>
                <button id="selectSet2" class="secondary" aria-pressed="false">Set 2</button>
              </div>
            </div>
          </div>
        </div>

        <div id="grid" class="grid" title="Click to toggle locked/unlocked"></div>

        <div class="placements" id="placements"></div>
      </div>
    </div>

    <div id="infoPanel" class="info-panel row" aria-label="Selection and Scoreboard panel">
      <div class="panel-column" id="selectedPanel">
        <div class="selected-area">
          <div class="selected-title">
            <span style="width:10px;height:10px;border-radius:50%;background:var(--rare);display:inline-block;"></span>
            <div>Shapes selected <span style="color:#9fb6d4;font-weight:400;margin-left:8px;font-size:12px">(click mini -> cycle rarity, right-click to delete, drag between sets)</span></div>
          </div>

          <div class="selected-sets">
            <div class="selected-set" style="min-width:160px">
              <div class="selected-set-header" style="display:flex;justify-content:space-between;align-items:center"><div>Set 1</div><div id="set1Count" style="color:#9fb6d4;font-weight:700">0</div></div>
              <div id="set1" class="selected-list" ondragover="event.preventDefault()"></div>
            </div>

            <div class="selected-set" style="min-width:160px">
              <div class="selected-set-header" style="display:flex;justify-content:space-between;align-items:center"><div>Set 2</div><div id="set2Count" style="color:#9fb6d4;font-weight:700">0</div></div>
              <div id="set2" class="selected-list" ondragover="event.preventDefault()"></div>
            </div>
          </div>
        </div>
      </div>

      <div class="panel-column" id="includedPanel">
        <div class="included-area" id="includedArea">
          <div class="included-title">
            <span style="width:10px;height:10px;border-radius:50%;background:#9fb6d4;display:inline-block;"></span>
            <div>Shapes included in the current solution</div>
          </div>
          <div class="included-sets">
            <div class="included-set">
              <div style="font-weight:700;color:var(--muted);display:flex;justify-content:space-between"><div>Set 1</div><div id="includedSet1Tiles" style="color:#9fb6d4">Tiles: 0</div></div>
              <div id="includedListSet1" class="included-list"></div>
            </div>
            <div class="included-set">
              <div style="font-weight:700;color:var(--muted);display:flex;justify-content:space-between"><div>Set 2</div><div id="includedSet2Tiles" style="color:#9fb6d4">Tiles: 0</div></div>
              <div id="includedListSet2" class="included-list"></div>
            </div>
          </div>

          <div id="extraIndicator" class="extra-indicator" style="display:none;">
            <div id="extraHeader"></div>
            <div id="extraList" class="extra-list"></div>
          </div>

        </div>
      </div>

      <div class="panel-column" id="scoreAndSaves" style="min-width:260px">
        <table class="scoreboard" id="scoreboard" aria-label="Rift Resistance scoreboard">
          <thead>
            <tr>
              <th class="colheader">Metric</th>
              <th class="colheader" style="background:var(--rare);color:#021029">Rare</th>
              <th class="colheader" style="background:var(--epic);">Epic</th>
              <th class="colheader" style="background:var(--super);">Super Epic</th>
            </tr>
          </thead>
          <tbody>
            <tr><td>Tiles (Set 1)</td><td id="sb_tiles1_rare">0</td><td id="sb_tiles1_epic">0</td><td id="sb_tiles1_super">0</td></tr>
            <tr><td>Rift Resistance (Set 1)</td><td id="sb_rr1_rare">0</td><td id="sb_rr1_epic">0</td><td id="sb_rr1_super">0</td></tr>
            <tr><td>Set Bonus (Set 1)</td><td id="sb_set1_rare">0</td><td id="sb_set1_epic">0</td><td id="sb_set1_super">0</td></tr>

            <tr><td>Tiles (Set 2)</td><td id="sb_tiles2_rare">0</td><td id="sb_tiles2_epic">0</td><td id="sb_tiles2_super">0</td></tr>
            <tr><td>Rift Resistance (Set 2)</td><td id="sb_rr2_rare">0</td><td id="sb_rr2_epic">0</td><td id="sb_rr2_super">0</td></tr>
            <tr><td>Set Bonus (Set 2)</td><td id="sb_set2_rare">0</td><td id="sb_set2_epic">0</td><td id="sb_set2_super">0</td></tr>
          </tbody>
        </table>

        <!-- Dual Set Bonus dropdown -->
        <div style="margin-bottom:8px">
          <div style="font-weight:700;color:var(--muted);margin-bottom:6px">Dual Set Bonus</div>
          <select id="dualSetBonus" disabled style="width:100%;padding:6px;border-radius:6px;background:#071421;color:var(--accent);border:1px solid rgba(255,255,255,0.02)">
            <option value="none">None</option>
          </select>
          <div id="dualSetHelp" style="font-size:12px;color:#9fb6d4;margin-top:6px">Locked — enable by unlocking at least 24 tiles.</div>
        </div>

        <div class="saves-area" id="savesArea">
          <div style="font-weight:700;color:var(--muted);margin-bottom:6px">Saved solutions (local)</div>
          <div id="saveSlots"></div>
        </div>
      </div>
    </div>
  </div>

  <div class="palette-wrap" id="paletteWrap">
    <div class="category-card" id="cardSmall">
      <div class="category-head"><span class="dot red"></span><div style="margin-left:6px">1–3 tiles</div></div>
      <div class="category-body" id="colA"></div>
    </div>

    <div class="category-card" id="card4">
      <div class="category-head"><span class="dot green"></span><div style="margin-left:6px">4 tiles</div></div>
      <div class="category-body" id="colB"></div>
    </div>

    <div class="category-card" id="card5">
      <div class="category-head"><span class="dot blue"></span><div style="margin-left:6px">5 tiles</div></div>
      <div class="category-body" id="colC"></div>
    </div>
  </div>
</div>

<script>
/* Safe single-file implementation.
   Known: This file focuses on ensuring grid & palette always load and initializations run in correct order.
   Changes: Added "Dual Set Bonus" dropdown which becomes active when unlocked tiles >= 24 and lists combinations
            of per-set set-bonus thresholds (0,9,12,15,18,21) that fit into the unlocked tile count.
            When a combination is selected, the solver forces final solutions to meet both set tile targets.
   Additional changes requested by user:
    - Saving a solution saves unlocked tiles and selected shapes + their rarities.
    - Overwrite and Delete confirm before action.
    - Reset removes shapes on grid AND clears "Shapes selected" and reverts grid to original default.
    - Clear removes shapes on grid AND clears "Shapes selected" but keeps current unlocked grid.
*/

const USER_KEY = 'hoangnh1630-rgb';
const SAVES_KEY = `polyomino_saves_${USER_KEY}_v1`;

window.addEventListener('error', (ev) => { console.error('Runtime error:', ev.error || ev.message, ev); });
window.addEventListener('unhandledrejection', (ev) => { console.error('Unhandled promise rejection:', ev.reason); });

document.addEventListener('DOMContentLoaded', () => {
  // State
  const ROWS = 7, COLS = 7;
  const RARITY_ORDER = ['rare','epic','super'];
  const RARITY_VALUES = { rare: 30, epic: 60, super: 120 };
  let unlocked = Array.from({length:ROWS}, ()=>Array.from({length:COLS}, ()=>false));
  let shapeTypes = [];
  let selectedInstances = [];
  let placedCells = {};
  let hasSolution = false;
  let activeSet = 1;

  // Dual set bonus thresholds (per-set tiles that produce set bonus)
  const SET_THRESHOLDS = [0,9,12,15,18,21];

  // DOM refs (guaranteed present)
  const gridEl = document.getElementById('grid');
  const colA = document.getElementById('colA');
  const colB = document.getElementById('colB');
  const colC = document.getElementById('colC');
  const set1ListEl = document.getElementById('set1');
  const set2ListEl = document.getElementById('set2');
  const includedListSet1El = document.getElementById('includedListSet1');
  const includedListSet2El = document.getElementById('includedListSet2');
  const includedSet1TilesEl = document.getElementById('includedSet1Tiles');
  const includedSet2TilesEl = document.getElementById('includedSet2Tiles');
  const placementsEl = document.getElementById('placements');
  const extraIndicatorEl = document.getElementById('extraIndicator');
  const extraHeaderEl = document.getElementById('extraHeader');
  const extraListEl = document.getElementById('extraList');
  const set1CountEl = document.getElementById('set1Count');
  const set2CountEl = document.getElementById('set2Count');
  const unlockedCounterEl = document.getElementById('unlockedCounter');
  const selectSet1Btn = document.getElementById('selectSet1');
  const selectSet2Btn = document.getElementById('selectSet2');
  const saveSlotsContainer = document.getElementById('saveSlots');
  const dualSetSelect = document.getElementById('dualSetBonus');
  const dualSetHelp = document.getElementById('dualSetHelp');

  // Helpers: geometry
  function normalize(cells){
    if(!cells.length) return [];
    const minr = Math.min(...cells.map(p=>p[0]));
    const minc = Math.min(...cells.map(p=>p[1]));
    return cells.map(p=>[p[0]-minr, p[1]-minc]).sort((a,b)=>a[0]-b[0]||a[1]-b[1]);
  }
  function rotate90(cells){ return normalize(cells.map(([r,c])=>[c,-r])); }
  function reflectX(cells){ return normalize(cells.map(([r,c])=>[-r,c])); }
  function all8_unique(cells){
    const t0 = normalize(cells);
    const raw=[];
    let cur=t0;
    for(let i=0;i<4;i++){ raw.push(cur); cur=rotate90(cur); }
    cur=reflectX(t0);
    for(let i=0;i<4;i++){ raw.push(cur); cur=rotate90(cur); }
    const seen=new Set(), out=[];
    for(const t of raw){
      const key = t.map(p=>p[0]+','+p[1]).join(';');
      if(!seen.has(key)){ seen.add(key); out.push(t); }
    }
    return out;
  }

  // Base shapes
  const baseShapes = [
    {name:"monomino", cells:[[0,0]]},
    {name:"domino", cells:[[0,0],[0,1]]},
    {name:"tromino-I", cells:[[0,0],[0,1],[0,2]]},
    {name:"tromino-L", cells:[[0,0],[0,1],[1,0]]},
    {name:"tetromino-I", cells:[[0,0],[0,1],[0,2],[0,3]]},
    {name:"tetromino-O", cells:[[0,0],[0,1],[1,0],[1,1]]},
    {name:"tetromino-T", cells:[[0,1],[1,0],[1,1],[1,2]]},
    {name:"tetromino-L", cells:[[0,0],[1,0],[2,0],[2,1]]},
    {name:"pentomino-T", cells:[[0,0],[0,1],[0,2],[1,1],[2,1]]},
    {name:"pentomino-U", cells:[[0,0],[0,2],[1,0],[1,1],[1,2]]},
    {name:"pentomino-V", cells:[[0,0],[1,0],[2,0],[2,1],[2,2]]},
    {name:"pentomino-X", cells:[[0,1],[1,0],[1,1],[1,2],[2,1]]},
    {name:"pentomino-Z", cells:[[0,0],[0,1],[1,1],[2,1],[2,2]]},
  ];

  function buildShapeTypes(){
    shapeTypes = [];
    let sid = 1;
    for(const b of baseShapes){
      const transforms = all8_unique(b.cells);
      for(const t of transforms){
        shapeTypes.push({ id: 'S'+sid, cells: t, baseName: b.name, size: t.length });
        sid++;
      }
    }
  }

  // Grid render
  function renderGrid(){
    gridEl.innerHTML = '';
    for(let r=0;r<ROWS;r++){
      for(let c=0;c<COLS;c++){
        const div = document.createElement('div');
        const k = r+','+c;
        const placed = placedCells[k];
        div.className = 'cell ' + (placed ? 'placed' : (unlocked[r][c] ? 'unlocked' : 'locked'));
        if(placed){
          if(placed.colorClass) div.classList.add(placed.colorClass);
          if(placed.rarity === 'rare') div.classList.add('outline-rare');
          else if(placed.rarity === 'epic') div.classList.add('outline-epic');
          else if(placed.rarity === 'super') div.classList.add('outline-super');
          div.dataset.rarity = placed.rarity;
          div.textContent = placed.pid;
        } else {
          div.textContent = '';
        }
        div.dataset.rc = k;
        div.title = placed ? `Placed ${placed.pid} (set ${placed.set})` : (unlocked[r][c] ? 'Unlocked' : 'Locked');
        div.addEventListener('click', ()=> {
          if(hasSolution) clearSolution();
          unlocked[r][c] = !unlocked[r][c];
          renderGrid(); updateUnlockedCounter(); updateDualSetBonusOptions(); updateExtraIndicator();
        });
        gridEl.appendChild(div);
      }
    }
    updateUnlockedCounter();
  }

  // Palette render
  function renderPalette(){
    colA.innerHTML=''; colB.innerHTML=''; colC.innerHTML='';
    const cats = { small:[], four:[], five:[], other:[] };
    for(const s of shapeTypes){
      if(s.size<=3) cats.small.push(s);
      else if(s.size===4) cats.four.push(s);
      else if(s.size===5) cats.five.push(s);
      else cats.other.push(s);
    }
    function makeRow(s){
      const row = document.createElement('div'); row.className='shape-row';
      const mini = document.createElement('div'); mini.className='mini';
      const maxR = Math.max(...s.cells.map(p=>p[0])); const maxC = Math.max(...s.cells.map(p=>p[1]));
      const h = Math.max(1, Math.min(3, maxR+1)); const w = Math.max(1, Math.min(3, maxC+1));
      mini.style.gridTemplateColumns = `repeat(${w},12px)`;
      for(let rr=0; rr<h; rr++){
        for(let cc=0; cc<w; cc++){
          const mc = document.createElement('div'); mc.className='mcell';
          if(s.cells.some(p=>p[0]===rr && p[1]===cc)) mc.classList.add('on');
          mini.appendChild(mc);
        }
      }
      const idEl = document.createElement('div'); idEl.className='shape-id'; idEl.textContent = s.id;
      const countWrap = document.createElement('div'); countWrap.className='count';
      const minus = document.createElement('button'); minus.textContent='-'; minus.style.padding='3px 6px';
      const inp = document.createElement('input'); inp.type='number'; inp.min='0'; inp.value = countInstancesOfShape(s.id);
      const plus = document.createElement('button'); plus.textContent='+'; plus.style.padding='3px 6px';
      minus.addEventListener('click', ()=>{
        removeOneInstanceOfShape(s.id);
        inp.value = countInstancesOfShape(s.id);
        renderSelectedList(); updateExtraIndicator();
      });
      plus.addEventListener('click', ()=>{
        addInstance(s.id, s.size, s.baseName);
        inp.value = countInstancesOfShape(s.id);
        renderSelectedList(); updateExtraIndicator();
      });
      inp.addEventListener('change', ()=>{
        let v = parseInt(inp.value||0); if(isNaN(v)||v<0) v=0;
        setInstancesCountForShape(s.id, v, s.size, s.baseName);
        inp.value = countInstancesOfShape(s.id);
        renderSelectedList(); updateExtraIndicator();
      });
      countWrap.appendChild(minus); countWrap.appendChild(inp); countWrap.appendChild(plus);
      row.appendChild(mini); row.appendChild(idEl); row.appendChild(countWrap);
      return row;
    }
    if(cats.small.length) cats.small.forEach(s=>colA.appendChild(makeRow(s))); else colA.innerHTML='<div style="color:#9fb6d4">No shapes</div>';
    if(cats.four.length) cats.four.forEach(s=>colB.appendChild(makeRow(s))); else colB.innerHTML='<div style="color:#9fb6d4">No shapes</div>';
    if(cats.five.length || cats.other.length){
      cats.five.forEach(s=>colC.appendChild(makeRow(s)));
      cats.other.forEach(s=>colC.appendChild(makeRow(s)));
    } else colC.innerHTML='<div style="color:#9fb6d4">No shapes</div>';
    setTimeout(adjustInfoPanelPosition, 30);
  }

  // Selected instances management
  let nextInstanceId = 1;
  function addInstance(shapeId, size, baseName){
    const iid = 'I' + (nextInstanceId++);
    selectedInstances.push({ iid, shapeId, rarity:'rare', size, baseName, set: activeSet });
  }
  function removeOneInstanceOfShape(shapeId){
    for(let i=selectedInstances.length-1;i>=0;i--){
      if(selectedInstances[i].shapeId === shapeId){ selectedInstances.splice(i,1); return; }
    }
  }
  function setInstancesCountForShape(shapeId, targetCount, size, baseName){
    const cur = selectedInstances.filter(s=>s.shapeId===shapeId).length;
    if(targetCount > cur){
      for(let i=0;i<targetCount-cur;i++) addInstance(shapeId,size,baseName);
    } else if(targetCount < cur){
      let removed = 0;
      for(let i=selectedInstances.length-1;i>=0 && removed < (cur-targetCount); i--){
        if(selectedInstances[i].shapeId === shapeId){ selectedInstances.splice(i,1); removed++; }
      }
    }
  }
  function countInstancesOfShape(shapeId){ return selectedInstances.filter(s=>s.shapeId===shapeId).length; }

  // Drag/drop + active set buttons
  function onDragStart(ev, iid){ ev.dataTransfer.setData('text/plain', iid); ev.dataTransfer.effectAllowed = 'move'; }
  function onDropToSet(ev, setNum){
    ev.preventDefault();
    const iid = ev.dataTransfer.getData('text/plain');
    const inst = selectedInstances.find(x=>x.iid===iid);
    if(inst){ inst.set = setNum; renderSelectedList(); }
  }

  selectSet1Btn.addEventListener('click', ()=>{ activeSet=1; selectSet1Btn.setAttribute('aria-pressed','true'); selectSet2Btn.setAttribute('aria-pressed','false'); selectSet1Btn.classList.remove('secondary'); selectSet2Btn.classList.add('secondary'); });
  selectSet2Btn.addEventListener('click', ()=>{ activeSet=2; selectSet2Btn.setAttribute('aria-pressed','true'); selectSet1Btn.setAttribute('aria-pressed','false'); selectSet2Btn.classList.remove('secondary'); selectSet1Btn.classList.add('secondary'); });
  // default style
  selectSet1Btn.classList.remove('secondary');

  // Render selected list
  function renderSelectedList(){
    set1ListEl.innerHTML = ''; set2ListEl.innerHTML = '';
    if(selectedInstances.length===0){
      set1ListEl.innerHTML = '<div style="color:#9fb6d4">No shapes selected</div>';
      set2ListEl.innerHTML = '<div style="color:#9fb6d4">No shapes selected</div>';
      set1CountEl.textContent='0'; set2CountEl.textContent='0'; return;
    }
    const s1 = selectedInstances.filter(x=>x.set===1);
    const s2 = selectedInstances.filter(x=>x.set===2);
    set1CountEl.textContent = s1.length; set2CountEl.textContent = s2.length;

    function createItem(inst){
      const item = document.createElement('div'); item.className = 'selected-item ' + inst.rarity;
      item.draggable = true; item.dataset.iid = inst.iid;
      const mini = document.createElement('div'); mini.className='selected-mini';
      const st = shapeTypes.find(s=>s.id===inst.shapeId);
      const cells = st ? st.cells : [[0,0]];
      for(let rr=0; rr<3; rr++){
        for(let cc=0; cc<3; cc++){
          const mc = document.createElement('div'); mc.className='mcell';
          if(cells.some(q=>q[0]===rr && q[1]===cc)) mc.classList.add('on');
          mini.appendChild(mc);
        }
      }
      item.appendChild(mini);
      item.addEventListener('click', (ev)=>{ ev.preventDefault(); cycleRarityForInstance(inst.iid); renderSelectedList(); });
      item.addEventListener('contextmenu', (ev)=>{ ev.preventDefault(); const idx = selectedInstances.findIndex(x=>x.iid===inst.iid); if(idx>=0) selectedInstances.splice(idx,1); renderSelectedList(); renderPalette(); updateExtraIndicator(); });
      item.addEventListener('dragstart', (ev)=> onDragStart(ev, inst.iid));
      return item;
    }
    s1.forEach(inst => set1ListEl.appendChild(createItem(inst)));
    s2.forEach(inst => set2ListEl.appendChild(createItem(inst)));

    set1ListEl.ondragover = (ev)=>{ ev.preventDefault(); set1ListEl.classList.add('droppable-over'); };
    set1ListEl.ondragleave = ()=> set1ListEl.classList.remove('droppable-over');
    set1ListEl.ondrop = (ev)=>{ set1ListEl.classList.remove('droppable-over'); onDropToSet(ev,1); };

    set2ListEl.ondragover = (ev)=>{ ev.preventDefault(); set2ListEl.classList.add('droppable-over'); };
    set2ListEl.ondragleave = ()=> set2ListEl.classList.remove('droppable-over');
    set2ListEl.ondrop = (ev)=>{ set2ListEl.classList.remove('droppable-over'); onDropToSet(ev,2); };

    updatePaletteInputs();
  }

  function cycleRarityForInstance(iid){
    const inst = selectedInstances.find(x=>x.iid===iid);
    if(!inst) return;
    const idx = RARITY_ORDER.indexOf(inst.rarity);
    inst.rarity = RARITY_ORDER[(idx+1)%RARITY_ORDER.length];
  }

  function updatePaletteInputs(){
    document.querySelectorAll('.category-body input[type="number"]').forEach(inp=>{
      const row = inp.closest('.shape-row'); if(!row) return;
      const idEl = row.querySelector('.shape-id'); if(!idEl) return;
      inp.value = countInstancesOfShape(idEl.textContent);
    });
  }

  // Included list
  function renderIncludedList(placements){
    includedListSet1El.innerHTML = ''; includedListSet2El.innerHTML = '';
    if(!placements || placements.length===0){
      includedListSet1El.innerHTML = '<div style="color:#9fb6d4">No shapes in current solution</div>';
      includedListSet2El.innerHTML = '<div style="color:#9fb6d4">No shapes in current solution</div>';
      includedSet1TilesEl.textContent='Tiles: 0'; includedSet2TilesEl.textContent='Tiles: 0'; return;
    }
    const p1 = placements.filter(p=>p.set===1);
    const p2 = placements.filter(p=>p.set===2);
    const tiles1 = p1.reduce((s,p)=>s + (p.placement.cells ? p.placement.cells.length : 0), 0);
    const tiles2 = p2.reduce((s,p)=>s + (p.placement.cells ? p.placement.cells.length : 0), 0);
    includedSet1TilesEl.textContent = `Tiles: ${tiles1}`; includedSet2TilesEl.textContent = `Tiles: ${tiles2}`;

    function mk(p){
      const item = document.createElement('div'); item.className='included-item ' + p.rarity;
      const mini = document.createElement('div'); mini.className = 'included-mini ' + p.rarity;
      const st = shapeTypes.find(s=>s.id===p.shapeId);
      const cells = st ? st.cells : [[0,0]];
      for(let rr=0; rr<3; rr++){
        for(let cc=0; cc<3; cc++){
          const mc = document.createElement('div'); mc.className='mcell';
          if(cells.some(q=>q[0]===rr && q[1]===cc)) mc.classList.add('on');
          mini.appendChild(mc);
        }
      }
      item.appendChild(mini); return item;
    }
    p1.forEach(p=> includedListSet1El.appendChild(mk(p)));
    p2.forEach(p=> includedListSet2El.appendChild(mk(p)));
  }
  function clearIncludedList(){ includedListSet1El.innerHTML = '<div style="color:#9fb6d4">No shapes in current solution</div>'; includedListSet2El.innerHTML = '<div style="color:#9fb6d4">No shapes in current solution</div>'; includedSet1TilesEl.textContent='Tiles: 0'; includedSet2TilesEl.textContent='Tiles: 0'; }

  // --- Fix: clearSolution implementation (was missing) ---
  function clearSolution(){
    // Remove any placed pieces and clear solution state, update UI.
    placedCells = {};
    hasSolution = false;
    // Clear placements display and included lists
    placementsEl.innerHTML = '';
    clearIncludedList();
    // Reset scoreboard to zeros
    updateScoreboard({ set1:{rare:0,epic:0,super:0}, set2:{rare:0,epic:0,super:0} }, 0, 0);
    // Remove any highlight and re-render grid
    clearHighlights();
    renderGrid();
    updateExtraIndicator();
  }
  // --- End fix ---

  // Placements generation & solver helpers (same as earlier robust implementation)
  function generatePlacementsForShapeType(shape){
    const cells = shape.cells;
    const maxR = Math.max(...cells.map(p=>p[0])); const maxC = Math.max(...cells.map(p=>p[1]));
    const placements = [];
    for(let ar=0; ar+maxR<ROWS; ar++){
      for(let ac=0; ac+maxC<COLS; ac++){
        const abs = cells.map(([r,c])=>[r+ar, c+ac]);
        let ok = true;
        for(const [r,c] of abs){
          if(r<0||r>=ROWS||c<0||c>=COLS){ ok=false; break; }
          if(!unlocked[r][c]) { ok=false; break; }
        }
        if(ok) placements.push({ shapeId: shape.id, anchor:[ar,ac], cells: abs });
      }
    }
    return placements;
  }

  function computeSetBonus(sumTiles){
    if(sumTiles < 9) return 0;
    const increments = Math.floor((sumTiles - 9) / 3);
    const capped = Math.min(increments, 4);
    return 265 * (capped + 1);
  }

  // Dual set bonus UI helpers
  function countUnlockedTiles(){
    let cnt=0; for(let r=0;r<ROWS;r++) for(let c=0;c<COLS;c++) if(unlocked[r][c]) cnt++;
    return cnt;
  }

  function generateDualCombos(totalUnlocked){
    // Produce pairs [a,b] where a>=b, each from SET_THRESHOLDS and a+b <= totalUnlocked.
    const result = [];
    const allowed = SET_THRESHOLDS.filter(x => x <= totalUnlocked);
    for(let i = allowed.length-1; i>=0; i--){
      for(let j = i; j>=0; j--){
        const a = allowed[i], b = allowed[j];
        if(a + b <= totalUnlocked){
          result.push([a,b]);
        }
      }
    }
    // Ensure we always include "None" by caller
    return result;
  }

  function updateDualSetBonusOptions(){
    const total = countUnlockedTiles();
    if(total < 24){
      dualSetSelect.disabled = true;
      dualSetHelp.textContent = 'Locked — enable by unlocking at least 24 tiles.';
      // keep current selection as 'none'
      if(dualSetSelect.value !== 'none') dualSetSelect.value = 'none';
      // clear other options
      dualSetSelect.innerHTML = '<option value="none">None</option>';
      return;
    }
    // update every time unlocked changes (the requirement states update when unlocked changes by increments of 3;
    // we regenerate regardless — it is cheap — but still keep ordering by descending a then b)
    const combos = generateDualCombos(total);
    dualSetSelect.innerHTML = '';
    // keep a none option
    const noneOpt = document.createElement('option'); noneOpt.value = 'none'; noneOpt.textContent = 'None'; dualSetSelect.appendChild(noneOpt);
    combos.forEach(([a,b])=>{
      const opt = document.createElement('option');
      opt.value = `${a}-${b}`;
      opt.textContent = `${a}-${b}`;
      dualSetSelect.appendChild(opt);
    });
    dualSetSelect.disabled = false;
    dualSetHelp.textContent = `Select a target split for set bonuses (total unlocked: ${total}).`;
  }

  // The runSolveOptimize is included above in previous iterations; we re-use the robust version here and
  // add enforcement of the selected dual-set thresholds.
  function runSolveOptimize(timeoutMs = 3500){
    const instances = selectedInstances.slice();
    if(instances.length === 0){
      clearSolution(); placementsEl.innerHTML = 'No pieces selected.'; clearIncludedList(); return;
    }

    const placementsByInstance = instances.map(inst => {
      const st = shapeTypes.find(s=>s.id===inst.shapeId);
      return st ? generatePlacementsForShapeType(st) : [];
    });

    for(let i=0;i<instances.length;i++){
      const inst = instances[i];
      if(inst.rarity==='super' && placementsByInstance[i].length===0){
        showInvalidSelection('One or more Super Epic pieces have no valid placement on the current unlocked grid. Super Epics must be included.');
        clearIncludedList(); return;
      }
    }
    const anyPlacement = placementsByInstance.some(arr=>arr.length>0);
    if(!anyPlacement){ showInvalidSelection('No valid placement exists for any selected piece on the current unlocked grid.'); clearIncludedList(); return; }

    // Determine selected dual thresholds
    let requiredSet1 = 0, requiredSet2 = 0;
    const sel = dualSetSelect.value;
    if(sel && sel !== 'none'){
      const parts = (''+sel).split('-').map(x=>parseInt(x,10)||0);
      if(parts.length===2){ requiredSet1 = Math.max(0, parts[0]); requiredSet2 = Math.max(0, parts[1]); }
    }

    // Quick feasibility check: total unlocked tiles smaller than required sum -> impossible
    const totalUnlocked = countUnlockedTiles();
    if(requiredSet1 + requiredSet2 > totalUnlocked){
      showInvalidSelection('Selected Dual Set Bonus cannot be satisfied with current unlocked tiles.');
      return;
    }

    // order indices
    const idxs = instances.map((inst, idx)=>({ idx, rarityOrder: inst.rarity==='super' ? 0 : (inst.rarity==='epic'?1:2), opts: placementsByInstance[idx].length || 0 }));
    idxs.sort((a,b)=> a.rarityOrder - b.rarityOrder || a.opts - b.opts);
    const indexMap = idxs.map(o=>o.idx);

    function placeAdds(placement){ return placement.cells.map(([r,c])=>`${r},${c}`); }
    function computeScores(cur){
      const rrRare = cur.set1.rare*RARITY_VALUES.rare + cur.set2.rare*RARITY_VALUES.rare;
      const rrEpic = cur.set1.epic*RARITY_VALUES.epic + cur.set2.epic*RARITY_VALUES.epic;
      const rrSuper = cur.set1.super*RARITY_VALUES.super + cur.set2.super*RARITY_VALUES.super;
      const rrSum = rrRare + rrEpic + rrSuper;
      const total1 = cur.set1.rare+cur.set1.epic+cur.set1.super;
      const total2 = cur.set2.rare+cur.set2.epic+cur.set2.super;
      const overflow = Math.max(0,total1-21);
      const set1ForBonus = Math.min(total1,21);
      const set2ForBonus = total2 + overflow;
      const setBonus1 = computeSetBonus(set1ForBonus);
      const setBonus2 = computeSetBonus(set2ForBonus);
      return { rrSum, setBonus1, setBonus2, total1, total2 };
    }

    function solveVariant(timeBudgetMs=1000, allowRares=true){
      const start = Date.now();
      const used = new Set();
      let best = { actualTotal:-1, placements:[], tilesByRarityBySet:{set1:{rare:0,epic:0,super:0}, set2:{rare:0,epic:0,super:0}}, rrSum:0, setBonus1:0, setBonus2:0, supersPlaced:0, epicsPlaced:0 };

      function backtrack(pos, curTiles, chosen){
        if(Date.now()-start > timeBudgetMs) return;
        if(pos>=indexMap.length){
          const mandatorySupers = instances.filter(x=>x.rarity==='super').length;
          const supersPlaced = curTiles.set1.super + curTiles.set2.super;
          if(supersPlaced < mandatorySupers) return;

          // enforce selected dual thresholds here
          const total1 = curTiles.set1.rare + curTiles.set1.epic + curTiles.set1.super;
          const total2 = curTiles.set2.rare + curTiles.set2.epic + curTiles.set2.super;
          if(total1 < requiredSet1) return;
          if(total2 < requiredSet2) return;

          const sc = computeScores(curTiles);
          const actualTotal = sc.rrSum + sc.setBonus1 + sc.setBonus2;
          const epicsPlaced = curTiles.set1.epic + curTiles.set2.epic;

          let better=false;
          if(actualTotal > best.actualTotal) better=true;
          else if(actualTotal === best.actualTotal){
            if(supersPlaced > (best.supersPlaced||0)) better=true;
            else if(supersPlaced === (best.supersPlaced||0)){
              if(epicsPlaced > (best.epicsPlaced||0)) better=true;
              else if(epicsPlaced === (best.epicsPlaced||0)){
                const raresPlaced = curTiles.set1.rare + curTiles.set2.rare;
                const bestRares = best.tilesByRarityBySet ? (best.tilesByRarityBySet.set1.rare + best.tilesByRarityBySet.set2.rare) : Infinity;
                if(raresPlaced < bestRares) better=true;
              }
            }
          }

          if(better){
            best.actualTotal = actualTotal;
            best.rrSum = sc.rrSum;
            best.setBonus1 = sc.setBonus1;
            best.setBonus2 = sc.setBonus2;
            best.tilesByRarityBySet = JSON.parse(JSON.stringify(curTiles));
            best.placements = chosen.slice();
            best.supersPlaced = supersPlaced;
            best.epicsPlaced = epicsPlaced;
          }
          return;
        }

        const instIdx = indexMap[pos];
        const inst = instances[instIdx];
        const opts = placementsByInstance[instIdx];
        const isRare = inst.rarity === 'rare';
        const mandatory = inst.rarity === 'super';

        for(const p of opts){
          if(isRare && !allowRares) continue;
          const keys = placeAdds(p); let conflict=false;
          for(const k of keys) if(used.has(k)){ conflict=true; break; }
          if(conflict) continue;
          for(const k of keys) used.add(k);
          const target = inst.set===2 ? 'set2' : 'set1';
          curTiles[target][inst.rarity] += inst.size;
          chosen.push({ iid: inst.iid, shapeId: inst.shapeId, rarity: inst.rarity, placement: p, set: inst.set });
          backtrack(pos+1, curTiles, chosen);
          chosen.pop();
          curTiles[target][inst.rarity] -= inst.size;
          for(const k of keys) used.delete(k);
        }
        if(!mandatory) backtrack(pos+1, curTiles, chosen);
      }

      backtrack(0, { set1:{rare:0,epic:0,super:0}, set2:{rare:0,epic:0,super:0} }, []);
      return best;
    }

    const t = Math.max(200, Math.floor(timeoutMs/3));
    const a = solveVariant(t,false);
    const a2 = solveVariant(t,true);
    const b = solveVariant(t,false);
    const b2 = solveVariant(t,true);
    const cand = [a2,b2,a,b].filter(c => c && c.placements && c.placements.length>0);

    if(cand.length===0){ showInvalidSelection('No valid tiling found (that satisfies the constraints).'); clearIncludedList(); return; }

    cand.sort((x,y)=>{
      if(x.actualTotal !== y.actualTotal) return y.actualTotal - x.actualTotal;
      if((x.supersPlaced||0) !== (y.supersPlaced||0)) return (y.supersPlaced||0) - (x.supersPlaced||0);
      if((x.epicsPlaced||0) !== (y.epicsPlaced||0)) return (y.epicsPlaced||0) - (x.epicsPlaced||0);
      return 0;
    });
    const best = cand[0];

    // Final validation: ensure best meets the selected dual thresholds (safety)
    const bestTotal1 = (best.tilesByRarityBySet && best.tilesByRarityBySet.set1) ? (best.tilesByRarityBySet.set1.rare + best.tilesByRarityBySet.set1.epic + best.tilesByRarityBySet.set1.super) : 0;
    const bestTotal2 = (best.tilesByRarityBySet && best.tilesByRarityBySet.set2) ? (best.tilesByRarityBySet.set2.rare + best.tilesByRarityBySet.set2.epic + best.tilesByRarityBySet.set2.super) : 0;
    if(bestTotal1 < requiredSet1 || bestTotal2 < requiredSet2){
      showInvalidSelection('No tiling found that satisfies the selected Dual Set Bonus targets.');
      return;
    }

    placedCells = {};
    for(let i=0;i<best.placements.length;i++){
      const p = best.placements[i];
      const pid = 'P'+(i+1);
      for(const [r,c] of p.placement.cells){
        placedCells[`${r},${c}`] = { pid, iid: p.iid, shapeId: p.shapeId, rarity: p.rarity, set: p.set, colorClass: sizeToColorClass(p.placement.cells.length) };
      }
    }
    updateScoreboard(best.tilesByRarityBySet || { set1:{rare:0,epic:0,super:0}, set2:{rare:0,epic:0,super:0} }, best.setBonus1 || 0, best.setBonus2 || 0);
    hasSolution = true;
    renderGrid();
    placementsEl.innerHTML = ''; const displayTotal = (best.rrSum || 0) + (best.setBonus1 || 0) + (best.setBonus2 || 0);
    placementsEl.appendChild(document.createTextNode(`Best Total: ${displayTotal}`));
    renderIncludedList(best.placements);
    updateExtraIndicator();
  }

  function sizeToColorClass(tileCount){
    if(tileCount>=1 && tileCount<=3) return 'placed-red';
    if(tileCount===4) return 'placed-green';
    if(tileCount===5) return 'placed-blue';
    return 'placed-blue';
  }

  function updateScoreboard(tilesByRarityBySet = { set1:{rare:0,epic:0,super:0}, set2:{rare:0,epic:0,super:0} }, setBonus1=0, setBonus2=0){
    const t1 = tilesByRarityBySet.set1, t2 = tilesByRarityBySet.set2;
    const rr1_rare = t1.rare * RARITY_VALUES.rare;
    const rr1_epic = t1.epic * RARITY_VALUES.epic;
    const rr1_super = t1.super * RARITY_VALUES.super;
    const rr2_rare = t2.rare * RARITY_VALUES.rare;
    const rr2_epic = t2.epic * RARITY_VALUES.epic;
    const rr2_super = t2.super * RARITY_VALUES.super;

    document.getElementById('sb_tiles1_rare').textContent = t1.rare;
    document.getElementById('sb_tiles1_epic').textContent = t1.epic;
    document.getElementById('sb_tiles1_super').textContent = t1.super;
    document.getElementById('sb_rr1_rare').textContent = rr1_rare;
    document.getElementById('sb_rr1_epic').textContent = rr1_epic;
    document.getElementById('sb_rr1_super').textContent = rr1_super;
    document.getElementById('sb_set1_rare').textContent = setBonus1;
    document.getElementById('sb_set1_epic').textContent = setBonus1;
    document.getElementById('sb_set1_super').textContent = setBonus1;

    document.getElementById('sb_tiles2_rare').textContent = t2.rare;
    document.getElementById('sb_tiles2_epic').textContent = t2.epic;
    document.getElementById('sb_tiles2_super').textContent = t2.super;
    document.getElementById('sb_rr2_rare').textContent = rr2_rare;
    document.getElementById('sb_rr2_epic').textContent = rr2_epic;
    document.getElementById('sb_rr2_super').textContent = rr2_super;
    document.getElementById('sb_set2_rare').textContent = setBonus2;
    document.getElementById('sb_set2_epic').textContent = setBonus2;
    document.getElementById('sb_set2_super').textContent = setBonus2;
  }

  function showInvalidSelection(err){
    clearSolution();
    placementsEl.innerHTML = `<div style="color:#fecaca;font-weight:700">Invalid selection — no tiling exists for the current selection.</div>
      <div style="color:#9fb6d4;margin-top:6px">${err || 'Please adjust your selected shapes and try again.'}</div>`;
  }

  // Extra indicator
  function getUncoveredUnlockedSet(){
    const set = new Set();
    for(let r=0;r<ROWS;r++) for(let c=0;c<COLS;c++){
      const k = r+','+c; if(unlocked[r][c] && !placedCells[k]) set.add(k);
    }
    return set;
  }
  function findExtraPlacementsExample(){
    const uncovered = getUncoveredUnlockedSet();
    if(uncovered.size===0) return [];
    const examples=[];
    for(const s of shapeTypes){
      if(s.size<=1) continue;
      const placements = generatePlacementsForShapeType(s);
      for(const p of placements){
        const ok = p.cells.every(([r,c]) => uncovered.has(r+','+c));
        if(ok){ examples.push({ shape:s, placement:p }); break; }
      }
    }
    return examples;
  }
  function clearHighlights(){ document.querySelectorAll('.cell.extra-highlight').forEach(el=>el.classList.remove('extra-highlight')); }
  function highlightPlacement(placement){ clearHighlights(); for(const [r,c] of placement.cells){ const el = document.querySelector(`.cell[data-rc="${r},${c}"]`); if(el) el.classList.add('extra-highlight'); } }
  function ensureExtraElements(){ return { extraIndicatorEl, extraHeaderEl, extraListEl }; }
  function updateExtraIndicator(){
    const els = ensureExtraElements(); const extraEl = els.extraIndicatorEl, headerEl = els.extraHeaderEl, listEl = els.extraListEl;
    if(!extraEl || !headerEl || !listEl) return;
    if(!hasSolution){ extraEl.style.display='none'; clearHighlights(); return; }
    const examples = findExtraPlacementsExample();
    if(examples.length===0){ extraEl.style.display='none'; clearHighlights(); return; }
    extraEl.style.display='block'; headerEl.textContent = `Additional placements possible: ${examples.length} oriented shape${examples.length>1?'s':''} (excluding monomino)`;
    listEl.innerHTML = '';
    for(const ex of examples){
      const item = document.createElement('div'); item.className='extra-item';
      const mini = document.createElement('div'); mini.className='mini';
      const s = ex.shape;
      const maxR = Math.max(...s.cells.map(p=>p[0])); const maxC = Math.max(...s.cells.map(p=>p[1]));
      const h = Math.max(1, Math.min(3, maxR+1)); const w = Math.max(1, Math.min(3, maxC+1));
      mini.style.gridTemplateColumns = `repeat(${w},12px)`;
      for(let rr=0; rr<h; rr++){ for(let cc=0; cc<w; cc++){ const mc = document.createElement('div'); mc.className='mcell'; if(s.cells.some(p=>p[0]===rr && p[1]===cc)) mc.classList.add('on'); mini.appendChild(mc); } }
      const idSpan = document.createElement('div'); idSpan.style.color='#cfe8ff'; idSpan.style.fontSize='13px'; idSpan.textContent = s.id;
      const plusBtn = document.createElement('button'); plusBtn.textContent = '+';
      plusBtn.addEventListener('click', ()=>{ const iid='I'+(nextInstanceId++); selectedInstances.push({ iid, shapeId:s.id, rarity:'rare', size:s.size, baseName:s.baseName, set: activeSet }); renderSelectedList(); updateExtraIndicator(); });
      item.addEventListener('mouseenter', ()=> highlightPlacement(ex.placement));
      item.addEventListener('mouseleave', ()=> clearHighlights());
      item.appendChild(mini); item.appendChild(idSpan); item.appendChild(plusBtn);
      listEl.appendChild(item);
    }
  }

  // Info panel placement
  function rectsIntersect(a,b){ return !(b.left >= a.right || b.right <= a.left || b.top >= a.bottom || b.bottom <= a.top); }
  function adjustInfoPanelPosition(){ const topRow=document.querySelector('.topRow'); if(!topRow.contains(document.getElementById('infoPanel'))) topRow.appendChild(document.getElementById('infoPanel')); }

  // Unlocked counter
  function updateUnlockedCounter(){ let cnt=0; for(let r=0;r<ROWS;r++) for(let c=0;c<COLS;c++) if(unlocked[r][c]) cnt++; unlockedCounterEl.textContent=`Unlocked: ${cnt}`; }

  // Save/load (localStorage)
  function loadSaves(){ try{ const raw = localStorage.getItem(SAVES_KEY); if(!raw) return [null,null,null]; const arr = JSON.parse(raw); while(arr.length<3) arr.push(null); return arr.slice(0,3); }catch(e){ console.error(e); return [null,null,null]; } }
  function saveSaves(arr){ localStorage.setItem(SAVES_KEY, JSON.stringify(arr.slice(0,3))); }
  function renderSaveSlots(){
    saveSlotsContainer.innerHTML=''; const slots=loadSaves();
    slots.forEach((slot,i)=>{
      const el=document.createElement('div'); el.className='save-slot';
      const mini=document.createElement('div'); mini.className='save-mini';
      for(let r=0;r<7;r++){ for(let c=0;c<7;c++){ const sc=document.createElement('div'); sc.className='s-cell'; if(slot && slot.placedCells && slot.placedCells[`${r},${c}`]) sc.classList.add('on'); mini.appendChild(sc); } }
      const meta=document.createElement('div'); meta.className='save-meta';
      const nameInput=document.createElement('input'); nameInput.className='save-input'; nameInput.value = slot ? slot.name : `Slot ${i+1}`;
      const infoLine=document.createElement('div'); infoLine.style.color='#9fb6d4'; infoLine.style.fontSize='12px'; infoLine.textContent = slot ? `RR: ${slot.total||0}` : 'Empty';
      const controls=document.createElement('div'); controls.className='save-controls';
      const saveBtn=document.createElement('button'); saveBtn.textContent = slot ? 'Overwrite' : 'Save';
      const loadBtn=document.createElement('button'); loadBtn.textContent = 'Load';
      const delBtn=document.createElement('button'); delBtn.textContent = 'Delete';
      controls.appendChild(saveBtn); controls.appendChild(loadBtn); controls.appendChild(delBtn);
      meta.appendChild(nameInput); meta.appendChild(infoLine); meta.appendChild(controls);
      el.appendChild(mini); el.appendChild(meta); saveSlotsContainer.appendChild(el);

      saveBtn.addEventListener('click', ()=>{
        if(!hasSolution || Object.keys(placedCells).length===0){ alert('No solution to save. Solve first.'); return; }
        // Confirm overwrite if slot occupied
        const arr=loadSaves();
        if(arr[i]){
          const ok = confirm(`Overwrite saved slot "${(arr[i].name||`Slot ${i+1}`)}"?`);
          if(!ok) return;
        }
        const name=nameInput.value||`Slot ${i+1}`;
        const placedCopy=JSON.parse(JSON.stringify(placedCells));
        const tilesByRarity = {
          set1:{ rare: parseInt(document.getElementById('sb_tiles1_rare').textContent)||0, epic: parseInt(document.getElementById('sb_tiles1_epic').textContent)||0, super: parseInt(document.getElementById('sb_tiles1_super').textContent)||0 },
          set2:{ rare: parseInt(document.getElementById('sb_tiles2_rare').textContent)||0, epic: parseInt(document.getElementById('sb_tiles2_epic').textContent)||0, super: parseInt(document.getElementById('sb_tiles2_super').textContent)||0 }
        };
        const totalMatch = placementsEl.textContent.match(/Best Total:\s*(\d+)/); const total = totalMatch ? parseInt(totalMatch[1]) : 0;
        // capture set bonuses from scoreboard display
        const setBonus1 = parseInt(document.getElementById('sb_set1_rare').textContent) || 0;
        const setBonus2 = parseInt(document.getElementById('sb_set2_rare').textContent) || 0;
        // Save unlocked grid and selectedInstances and nextInstanceId to allow restoring selection and rarities
        const unlockedCopy = unlocked.map(row => row.slice());
        const selectedCopy = JSON.parse(JSON.stringify(selectedInstances));
        arr[i] = { name, placedCells: placedCopy, tilesByRarity, total, timestamp: Date.now(), unlocked: unlockedCopy, selectedInstances: selectedCopy, nextInstanceId, setBonus1, setBonus2 };
        saveSaves(arr); renderSaveSlots();
      });
      loadBtn.addEventListener('click', ()=>{
        const arr=loadSaves(); const s=arr[i]; if(!s){ alert('Empty slot'); return; }
        // Restore unlocked grid and selected instances as saved
        if(s.unlocked && Array.isArray(s.unlocked) && s.unlocked.length===ROWS){
          unlocked = s.unlocked.map(row => row.slice());
        }
        if(s.selectedInstances && Array.isArray(s.selectedInstances)){
          selectedInstances = JSON.parse(JSON.stringify(s.selectedInstances));
          // ensure nextInstanceId is set so future adds don't collide
          if(typeof s.nextInstanceId === 'number' && s.nextInstanceId > nextInstanceId) nextInstanceId = s.nextInstanceId;
          else {
            // find max iid numeric and set nextInstanceId appropriately
            const maxIid = selectedInstances.reduce((mx,si)=> {
              const n = parseInt((''+si.iid).replace(/^I/,''));
              return isNaN(n) ? mx : Math.max(mx,n);
            }, 0);
            nextInstanceId = Math.max(nextInstanceId, maxIid + 1);
          }
        } else {
          selectedInstances = [];
        }

        // Restore placedCells and scoreboard
        placedCells = JSON.parse(JSON.stringify(s.placedCells || {})); hasSolution=true;
        const tilesByRarity = s.tilesByRarity || { set1:{rare:0,epic:0,super:0}, set2:{rare:0,epic:0,super:0} };
        const setB1 = s.setBonus1 || 0;
        const setB2 = s.setBonus2 || 0;
        renderPalette(); renderSelectedList();
        renderGrid(); updateScoreboard(tilesByRarity, setB1, setB2);
        // reconstruct included placements approximately
        const byPid={};
        for(const k of Object.keys(placedCells)){ const p=placedCells[k]; if(!byPid[p.pid]) byPid[p.pid]={ iid:p.iid, shapeId:p.shapeId||'S1', rarity:p.rarity, placement:{cells:[]}, set:p.set }; const [r,c]=k.split(',').map(Number); byPid[p.pid].placement.cells.push([r,c]); }
        const placements=[]; for(const pid of Object.keys(byPid)) placements.push(byPid[pid]);
        renderIncludedList(placements); updateExtraIndicator(); updateDualSetBonusOptions();
      });
      delBtn.addEventListener('click', ()=>{ const arr=loadSaves(); if(!arr[i]) return; const ok = confirm(`Delete saved slot "${(arr[i].name||`Slot ${i+1}`)}"?`); if(!ok) return; arr[i]=null; saveSaves(arr); renderSaveSlots(); });
    });
  }

  // UI wiring
  document.getElementById('solveBtn').addEventListener('click', ()=>{ placementsEl.innerHTML='Optimizing...'; setTimeout(()=>runSolveOptimize(3500),50); });
  document.getElementById('resetGrid').addEventListener('click', ()=>{
    // Reset: delete all shapes shown on the grid AND shapes in "Shapes selected" and revert the current grid back to original state.
    selectedInstances = []; renderPalette(); renderSelectedList();
    clearSolution();
    applyDefaultCenter();
    renderGrid();
    updateDualSetBonusOptions();
    updateExtraIndicator();
    setTimeout(adjustInfoPanelPosition,30);
  });
  document.getElementById('clearAll').addEventListener('click', ()=>{
    // Clear: deletes all shapes shown on the grid and shapes in "Shapes selected" while keeping current grid.
    selectedInstances=[];
    renderPalette();
    renderSelectedList();
    clearSolution();
    placementsEl.innerHTML='';
    updateScoreboard();
    clearIncludedList();
    updateDualSetBonusOptions();
    setTimeout(adjustInfoPanelPosition,30);
  });
  window.addEventListener('resize', ()=> setTimeout(adjustInfoPanelPosition,30));

  // init functions: apply center, build shapes, render everything
  function applyDefaultCenter(){ unlocked = Array.from({length:ROWS}, ()=>Array.from({length:COLS}, ()=>false)); const startR=Math.floor((ROWS-3)/2), startC=Math.floor((COLS-5)/2); for(let r=startR;r<startR+3;r++) for(let c=startC;c<startC+5;c++) unlocked[r][c]=true; }

  // boot
  applyDefaultCenter(); buildShapeTypes(); renderPalette(); renderGrid(); renderSelectedList(); updateScoreboard(); clearIncludedList(); updateExtraIndicator(); renderSaveSlots(); updateDualSetBonusOptions(); setTimeout(adjustInfoPanelPosition,50);
});
</script>
</body>
</html>
